<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Levin Luo">
    
    <meta name="description" content="Stay hungry、stay foolish.">
    
    
    
    
    
    
    <title>RxSwift核心概念 | One Piece</title>
    <link href=”http://yoursite.com“ rel=”prefetch” />

    <link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/css/aos.css">
<link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/aos.js"></script>
    <script src="/js/highslide/highslide-full.min.js"></script>
    <link rel="stylesheet" href="/js/highslide/highslide.css">
    <style type="text/css">
        @media (max-width: 768px) {
            body {
                background-color: #f0f0f0;
                background: url('/imgs/xsbg.gif');
                background-attachment: fixed;
            }
        }
    </style>
    
    <!--<script type="text/javascript">
      if (document.images) {
        var avatar = new Image();
        avatar.src = '/imgs/avatar.jpg'
        var previews = 'preview1.jpg,preview2.jpg,preview3.jpg,preview4.jpg'.split(',')
        var previewsPreLoad = []
        for(var i = 0; i < length; i++) {
          previewsPreLoad.push(new Image())
          previewsPreLoad[previewsPreLoad.length - 1].src = '/imgs/preview' + previews[i]
        }
      }
    </script>-->
</head>
<body>
    <!-- 背景轮播图功能 -->
    <section class="hidden-xs">
    <ul class="cb-slideshow">
        <li><span>天若</span></li>
        <li><span>有情</span></li>
        <li><span>天亦老</span></li>
        <li><span>我为</span></li>
        <li><span>长者</span></li>
        <li><span>续一秒</span></li>
    </ul>
</section>
    <!-- 欧尼酱功能, 谁用谁知道 -->
    
    <header class="navbar navbar-inverse" id="gal-header">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".bs-navbar-collapse"
                    aria-expanded="false">
                <span class="fa fa-lg fa-reorder"></span>
            </button>
            <a href="http://yoursite.com">
                
                <style>
                    #gal-header .navbar-brand {
                        height: 54px;
                        line-height: 24px;
                        font-size: 28px;
                        opacity: 1;
                        background-color: rgba(0,0,0,0);
                        text-shadow: 0 0 5px #fff,0 0 10px #fff,0 0 15px #fff,0 0 20px #228DFF,0 0 35px #228DFF,0 0 40px #228DFF,0 0 50px #228DFF,0 0 75px #228DFF;
                    }
                </style>
                <!-- 这里使用文字(navbar_text or config.title) -->
                <div class="navbar-brand">One Piece</div>
                
            </a>
        </div>
        <div class="collapse navbar-collapse bs-navbar-collapse">
            <ul class="nav navbar-nav" id="menu-gal">
                
                
                <li class="">
                    <a href="/">
                        <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                
                
                <li class="">
                    <a href="/archives">
                        <i class="fa fa-archive"></i>归档
                    </a>
                </li>
                
                
                
                
                <li class="">
                    <a href="/categories">
                        <i class="fa fa-list"></i>分类
                    </a>
                </li>
                
                
                
                
                
                <li class="dropdown">
                    <!-- TODO 添加hover dropdown效果 -->
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false" data-hover="dropdown">
                        <i class="fa fa-tags"></i>标签
                    </a>
                    <ul class="dropdown-menu">
                        
                        
                        <li>
                            <a href="/tags/RxSWift/">RxSWift</a>
                        </li>
                        
                        <li>
                            <a href="/tags/RxSwift/">RxSwift</a>
                        </li>
                        
                        <li>
                            <a href="/tags/UI篇/">UI篇</a>
                        </li>
                        
                        
                        <li>
                            <a href="/tags">...</a>
                        </li>
                        
                        
                    </ul>
                </li>
                
                
                
                
                <li class="">
                    <a href="/about">
                        <i class="fa fa-user"></i>关于我
                    </a>
                </li>
                
                
            </ul>
        </div>
    </div>
</header>
    <div id="gal-body">
        <div class="container">
            <div class="row">
                <div class="col-md-8 gal-right" id="mainstay">
                    
<article class="article well article-body" id="article">
    <div class="breadcrumb">
        <i class="fa fa-home"></i>
        <a href="http://yoursite.com">One Piece</a>
        >
        <span>RxSwift核心概念</span>
    </div>
    <!-- 大型设备详细文章 -->
    <div class="hidden-xs">
        <div class="title-article">
            <h1>
                <a href="/2017/10/20/RxSwift核心概念/">RxSwift核心概念</a>
            </h1>
        </div>
        <div class="tag-article">
            
            <span class="label label-gal">
                <i class="fa fa-tags"></i>
                
                <a href="/tags/RxSwift/">RxSwift</a>
                
            </span>
            
            <span class="label label-gal">
                <i class="fa fa-calendar"></i> 2017-10-20
            </span>
            
        </div>
    </div>
    <!-- 小型设备详细文章 -->
    <div class="visible-xs">
        <center>
            <div class="title-article">
                <h4>
                    <a href="/2017/10/20/RxSwift核心概念/">RxSwift核心概念</a>
                </h4>
            </div>
            <p>
                <i class="fa fa-calendar"></i> 2017-10-20
            </p>
            <p>
                
                <i class="fa fa-tags"></i>
                
                <a href="/tags/RxSwift/">RxSwift</a>
                
                
                
            </p>
        </center>
    </div>
    <div class="content-article">
        <p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发，维护。<br><br>RxSwift的作用是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程.</p>
<h1 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h1><p>通过高阶函数以点为连接将多个函数连接在一起完成参数传递和复杂的操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">enum MyError: Error &#123;</span><br><span class="line">    case DivZero // 除数为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Calculate: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    class func ts_calculate(make: (Calculate) -&gt; Void) &#123;</span><br><span class="line">        let calculate = Calculate()</span><br><span class="line">        make(calculate)</span><br><span class="line">        print(calculate.result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //保存计算结果</span><br><span class="line">    var result: Float = 0.0</span><br><span class="line"></span><br><span class="line">    //加</span><br><span class="line">    func add(num: Float) -&gt; Calculate &#123;</span><br><span class="line">            result += num</span><br><span class="line">            return self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //减</span><br><span class="line">    func sub(num: Float) -&gt; Calculate &#123;</span><br><span class="line">        result -= num</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    //乘</span><br><span class="line">    func mul(num: Float) -&gt; Calculate &#123;</span><br><span class="line">        result *= num</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    //除</span><br><span class="line">    func div(num: Float) throws -&gt; Calculate &#123;</span><br><span class="line">        guard num != 0 else&#123;</span><br><span class="line">            throw MyError.DivZero</span><br><span class="line">        &#125;</span><br><span class="line">        result /= num</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line"> Calculate.ts_calculate &#123; (make) in</span><br><span class="line">            </span><br><span class="line">            make.add(num: 6).sub(num: 2).mul(num: 5)</span><br><span class="line">            </span><br><span class="line">            do &#123;</span><br><span class="line">                try make.div(num: 0)</span><br><span class="line">            &#125;catch &#123;</span><br><span class="line">                print(error)</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h1><p>响应式编程根源于 FRP（函数响应式编程）命令驱动的编程方式，是以异步数据流的形式进行编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var B = 20</span><br><span class="line">let C = A * 2 + B</span><br><span class="line">// 当前值</span><br><span class="line">// A = 10, B = 20, C = 40</span><br><span class="line">A = 0</span><br><span class="line">// 当前值</span><br><span class="line">// A = 0, B = 20, C = 40</span><br></pre></td></tr></table></figure>
<p>在这里把a,b,c当成某个状态，c是a,b两个状态的组合，正常的编程中，在计算了c的状态之后，再去改变a,b的状态是不会影响到c的状态的。所以在正常编程中我们要去记录很多状态并及时更新状态，比如网络请求的状态，下拉刷新的状态。各种各样的事件响应方式，无形中增加了编码的复杂度。而在响应式编程中，每一个状态的改变都会发出一个信号，更新与之关联的状态。</p>
<p>一般可使用弹珠图来展示这个原理。如下图所示，每一行表示连续的一段时间，每一个弹珠表示发生在特定时刻的一个事件。<br><img src="http://ww1.sinaimg.cn/mw690/005YMFkugy1fqy3ja9xt5j30id05k0ss.jpg" alt=""></p>
<h1 id="Observable-可被监听的序列"><a href="#Observable-可被监听的序列" class="headerlink" title="Observable - 可被监听的序列"></a>Observable - 可被监听的序列</h1><p>Observable也就是一个被观察的对象，是一个事件序列，订阅者可以订阅它，监测事件的发生(Next\Complete\Error)</p>
<ul>
<li>.onNext(element) 表示新的事件数据。</li>
<li>.onError(error) 表示事件序列因异常而完结。</li>
<li>.onCompleted() 表示事件序列完结。</li>
</ul>
<h2 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let numbers: Observable&lt;Int&gt; = Observable.create &#123; observer -&gt; Disposable in</span><br><span class="line"></span><br><span class="line">    observer.onNext(0)</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onNext(2)</span><br><span class="line">    observer.onNext(3)</span><br><span class="line">    observer.onNext(4)</span><br><span class="line">    observer.onNext(5)</span><br><span class="line">    observer.onNext(6)</span><br><span class="line">    observer.onNext(7)</span><br><span class="line">    observer.onNext(8)</span><br><span class="line">    observer.onNext(9)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line"></span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line">    .subscribe(onNext: &#123; num in</span><br><span class="line">        print(&quot;取得 num 成功: \(num)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;取得 num 失败 Error: \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;取得 num 任务成功完成&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/mw690/005YMFkugy1fqybs8xawxj30jy029dft.jpg" alt=""></p>
<h3 id="特征序列"><a href="#特征序列" class="headerlink" title="特征序列"></a>特征序列</h3><p>RxSwift 里面 Observable 也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码</p>
<h4 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h4><p>Single 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能发出一个元素，要么产生一个 error 事件。</p>
<p>一个比较常见的例子就是执行 HTTP 请求，然后返回一个应答或错误。不过你也可以用 Single 来描述任何只有一个元素的序列,不共享状态变化.也可以对 Observable 调用 .asSingle() 方法，将它转换为 Single</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return Single&lt;[String: Any]&gt;.create &#123; single in</span><br><span class="line">        let url = URL(string: &quot;https://api.github.com/repos/\(repo)&quot;)!</span><br><span class="line">        let task = URLSession.shared.dataTask(with: url) &#123;</span><br><span class="line">            data, _, error in</span><br><span class="line"></span><br><span class="line">            if let error = error &#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            guard let data = data,</span><br><span class="line">                  let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                  let result = json as? [String: Any] else &#123;</span><br><span class="line">                single(.error(DataError.cantParseJSON))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            single(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task.resume()</span><br><span class="line"></span><br><span class="line">        return Disposables.create &#123; task.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRepo(&quot;ReactiveX/RxSwift&quot;)</span><br><span class="line">    .subscribe(onSuccess: &#123; json in</span><br><span class="line">        print(&quot;JSON: &quot;, json)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Error: &quot;, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h4 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h4><p>Completable 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能产生一个 completed 事件，要么产生一个 error 事件,不共享状态变化.</p>
<p>Completable 适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 Observable<void> 有点相似。</void></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func cacheLocally() -&gt; Completable &#123;</span><br><span class="line">    return Completable.create &#123; completable in</span><br><span class="line">       // Store some data locally</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       guard success else &#123;</span><br><span class="line">           completable(.error(CacheError.failedCaching))</span><br><span class="line">           return Disposables.create &#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       completable(.completed)</span><br><span class="line">       return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cacheLocally()</span><br><span class="line">    .subscribe(onCompleted: &#123;</span><br><span class="line">        print(&quot;Completed with no error&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Completed with an error: \(error.localizedDescription)&quot;)</span><br><span class="line">     &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe 是 Observable 的另外一个版本。它介于 Single 和 Completable 之间，它要么只能发出一个元素，要么产生一个 completed 事件，要么产生一个 error 事件,不共享状态变化.可以对 Observable 调用 .asMaybe() 方法，将它转换为 Maybe。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func generateString() -&gt; Maybe&lt;String&gt; &#123;</span><br><span class="line">    return Maybe&lt;String&gt;.create &#123; maybe in</span><br><span class="line">        maybe(.success(&quot;RxSwift&quot;))</span><br><span class="line"></span><br><span class="line">        // OR</span><br><span class="line"></span><br><span class="line">        maybe(.completed)</span><br><span class="line"></span><br><span class="line">        // OR</span><br><span class="line"></span><br><span class="line">        maybe(.error(error))</span><br><span class="line"></span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateString()</span><br><span class="line">    .subscribe(onSuccess: &#123; element in</span><br><span class="line">        print(&quot;Completed with element \(element)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Completed with an error \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;Completed with no element&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p>它主要是为了简化 UI 层的代码.不会产生 error 事件,一定在 MainScheduler 监听（主线程监听）,共享状态变化.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">      (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>这段代码的主要目的是：</p>
<ul>
<li>取出用户输入稳定后的内容</li>
<li>向服务器请求一组结果</li>
<li>将返回的结果绑定到两个 UI 元素上：tableView 和 显示结果数量的label</li>
</ul>
<p>那么这里存在什么问题？</p>
<ul>
<li>如果 fetchAutoCompleteItems 的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求。</li>
<li>如果 fetchAutoCompleteItems 在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃。</li>
<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果。</li>
</ul>
<p>一个更好的方案是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class="line">            .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class="line">    &#125;</span><br><span class="line">    .share(replay: 1)                             // HTTP 请求是被共享的</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">      (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>以下是使用 Driver 优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class="line">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">      (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>drive 方法只能被 Driver 调用。这意味着，如果你发现代码所存在 drive，那么这个序列不会产生错误事件并且一定在主线程监听。这样你可以安全的绑定 UI 元素。</p>
<h1 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer - 观察者"></a>Observer - 观察者</h1><p>观察者需要去订阅(subscribe)被观察者(Observable)，才能收到Observable的事件通知消息.而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers</span><br><span class="line">    .subscribe(onNext: &#123; num in</span><br><span class="line">        print(&quot;取得 num 成功: \(num)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;取得 num 失败 Error: \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;取得 num 任务成功完成&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="特征观察者"><a href="#特征观察者" class="headerlink" title="特征观察者"></a>特征观察者</h2><h3 id="AnyObserver"><a href="#AnyObserver" class="headerlink" title="AnyObserver"></a>AnyObserver</h3><p>AnyObserver 可以用来描叙任意一种观察者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let observer: AnyObserver&lt;Data&gt; = AnyObserver &#123; (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(&quot;Data Task Success with count: \(data.count)&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;Data Task Error: \(error)&quot;)</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URLSession.shared.rx.data(request: URLRequest(url: url))</span><br><span class="line">    .subscribe(observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>不会处理错误事件,确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler）.一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let observer: AnyObserver&lt;Bool&gt; = AnyObserver &#123; [weak self] (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let isHidden):</span><br><span class="line">        self?.usernameValidOutlet.isHidden = isHidden</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>由于这个观察者是一个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执行.因此一个更好的方案就是使用 Binder：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let observer: Binder&lt;Bool&gt; = Binder(usernameValidOutlet) &#123; (view, isHidden) in</span><br><span class="line">    view.isHidden = isHidden</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>Binder 可以只处理 next 事件，并且保证响应 next 事件的代码一定会在给定 Scheduler 上执行，这里采用默认的 MainScheduler。</p>
<h1 id="可被监听的序列也是观察者"><a href="#可被监听的序列也是观察者" class="headerlink" title="可被监听的序列也是观察者"></a>可被监听的序列也是观察者</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 作为可被监听的序列</span><br><span class="line">let observable = textField.rx.text</span><br><span class="line">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br><span class="line">// 作为观察者</span><br><span class="line">let observer = textField.rx.text</span><br><span class="line">let text: Observable&lt;String?&gt; = ...</span><br><span class="line">text.bind(to: observer)</span><br></pre></td></tr></table></figure>
<p>有许多 UI 控件都存在这种特性，例如：switch的开关状态，segmentedControl的选中索引号，datePicker的选中日期等等。</p>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>AsyncSubject 将在源 Observable 产生完成事件后，发出最后一个元素（仅仅只有最后一个元素），如果源 Observable 没有发出任何元素，只有一个完成事件。那 AsyncSubject 也只有一个完成事件。它会对随后的观察者发出最终元素。如果源 Observable 因为产生了一个 error 事件而中止， AsyncSubject 就不会发出任何元素，而是将这个 error 事件发送出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = AsyncSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐶&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br><span class="line">subject.onNext(&quot;🐹&quot;)</span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Subscription: 1 Event: next(🐹)</span><br><span class="line">Subscription: 1 Event: completed</span><br></pre></td></tr></table></figure></p>
<h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>PublishSubject 将对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者。如果你希望观察者接收到所有的元素，你可以通过使用 Observable 的 create 方法来创建 Observable，或者使用 ReplaySubject。如果源 Observable 因为产生了一个 error 事件而中止， PublishSubject 就不会发出任何元素，而是将这个 error 事件发送出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐶&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🅰️&quot;)</span><br><span class="line">subject.onNext(&quot;🅱️&quot;)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Subscription: 1 Event: next(🐶)</span><br><span class="line">Subscription: 1 Event: next(🐱)</span><br><span class="line">Subscription: 1 Event: next(🅰️)</span><br><span class="line">Subscription: 2 Event: next(🅰️)</span><br><span class="line">Subscription: 1 Event: next(🅱️)</span><br><span class="line">Subscription: 2 Event: next(🅱️)</span><br></pre></td></tr></table></figure>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>ReplaySubject 将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的 ReplaySubject，有的只会将最新的 n 个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把 ReplaySubject 当作观察者来使用，注意不要在多个线程调用 onNext, onError 或 onCompleted。这样会导致无序调用，将造成意想不到的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐶&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🅰️&quot;)</span><br><span class="line">subject.onNext(&quot;🅱️&quot;)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Subscription: 1 Event: next(🐶)</span><br><span class="line">Subscription: 1 Event: next(🐱)</span><br><span class="line">Subscription: 2 Event: next(🐱)</span><br><span class="line">Subscription: 1 Event: next(🅰️)</span><br><span class="line">Subscription: 2 Event: next(🅰️)</span><br><span class="line">Subscription: 1 Event: next(🅱️)</span><br><span class="line">Subscription: 2 Event: next(🅱️)</span><br></pre></td></tr></table></figure>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>当观察者对 BehaviorSubject 进行订阅时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果源 Observable 因为产生了一个 error 事件而中止， BehaviorSubject 就不会发出任何元素，而是将这个 error 事件发送出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = BehaviorSubject(value: &quot;🔴&quot;)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐶&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🅰️&quot;)</span><br><span class="line">subject.onNext(&quot;🅱️&quot;)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">  .subscribe &#123; print(&quot;Subscription: 3 Event:&quot;, $0) &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🍐&quot;)</span><br><span class="line">subject.onNext(&quot;🍊&quot;)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Subscription: 1 Event: next(🔴)</span><br><span class="line">Subscription: 1 Event: next(🐶)</span><br><span class="line">Subscription: 1 Event: next(🐱)</span><br><span class="line">Subscription: 2 Event: next(🐱)</span><br><span class="line">Subscription: 1 Event: next(🅰️)</span><br><span class="line">Subscription: 2 Event: next(🅰️)</span><br><span class="line">Subscription: 1 Event: next(🅱️)</span><br><span class="line">Subscription: 2 Event: next(🅱️)</span><br><span class="line">Subscription: 3 Event: next(🅱️)</span><br><span class="line">Subscription: 1 Event: next(🍐)</span><br><span class="line">Subscription: 2 Event: next(🍐)</span><br><span class="line">Subscription: 3 Event: next(🍐)</span><br><span class="line">Subscription: 1 Event: next(🍊)</span><br><span class="line">Subscription: 2 Event: next(🍊)</span><br><span class="line">Subscription: 3 Event: next(🍊)</span><br></pre></td></tr></table></figure>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>在 Swift 中我们经常会用 var 关键字来声明变量.RxSwift 提供的 Variable 实际上是 var 的 Rx 版本，你可以将它看作是 RxVar.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//使用 var：</span><br><span class="line">// 在 ViewController 中</span><br><span class="line">var model: Model? = nil &#123;</span><br><span class="line">    didSet &#123; updateUI(with: model) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    model = getModel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUI(with model: Model?) &#123; ... &#125;</span><br><span class="line">func getModel() -&gt; Model &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">//使用 Variable：</span><br><span class="line">// 在 ViewController 中</span><br><span class="line">let model: Variable&lt;Model?&gt; = Variable(nil)</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    model.asObservable()</span><br><span class="line">        .subscribe(onNext: &#123; [weak self] model in</span><br><span class="line">            self?.updateUI(with: model)</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">    model.value = getModel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUI(with model: Model?) &#123; ... &#125;</span><br><span class="line">func getModel() -&gt; Model &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>第一种使用 var 的方式十分常见，在 ViewController 中监听 Model 的变化，然后刷新页面。</p>
<p>第二种使用 Variable 则是 RxSwift 独有的。Variable 几乎提供了 var 的所有功能。另外，加上一条非常重要的特性，就是可以通过调用 asObservable() 方法转换成序列。然后你可以对这个序列应用操作符，来合成其他的序列。所以，如果我们声明的变量需要提供 Rx 支持，那就选用 Variable 这个类型。</p>
<p>Variable 封装了一个 BehaviorSubject，所以它会持有当前值，并且 Variable 会对新的观察者发送当前值。它不会产生 error 事件。Variable 在 deinit 时，会发出一个 completed 事件。</p>
<h1 id="Disposable-可被清除的资源"><a href="#Disposable-可被清除的资源" class="headerlink" title="Disposable - 可被清除的资源"></a>Disposable - 可被清除的资源</h1><p>通常来说，一个序列如果发出了 error 或者 completed 事件，那么所有内部资源都会被释放。如果你需要提前释放这些资源或取消订阅的话，那么你可以对返回的 可被清除的资源（Disposable） 调用 dispose 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var disposable: Disposable?</span><br><span class="line"></span><br><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">    super.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">    self.disposable = textField.rx.text.orEmpty</span><br><span class="line">        .subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class="line">    super.viewWillDisappear(animated)</span><br><span class="line"></span><br><span class="line">    self.disposable?.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 dispose 方法后，订阅将被取消，并且内部资源都会被释放。通常情况下，你是不需要手动调用 dispose 方法的，这里只是做个演示而已。我们推荐使用 清除包（DisposeBag） 或者 takeUntil 操作符 来管理订阅的生命周期。</p>
<h2 id="清除包（DisposeBag）"><a href="#清除包（DisposeBag）" class="headerlink" title="清除包（DisposeBag）"></a>清除包（DisposeBag）</h2><p>因为我们用的是 Swift ，所以我们更习惯于使用 ARC 来管理内存。那么我们能不能用 ARC 来管理订阅的生命周期了。答案是肯定了，你可以用 清除包（DisposeBag） 来实现这种订阅管理机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">    super.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">    textField.rx.text.orEmpty</span><br><span class="line">        .subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class="line">        .disposed(by: self.disposeBag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class="line">    super.viewWillDisappear(animated)</span><br><span class="line"></span><br><span class="line">    self.disposeBag = DisposeBag()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h2><p>另外一种实现自动取消订阅的方法就是使用 takeUntil 操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    _ = usernameValid</span><br><span class="line">        .takeUntil(self.rx.deallocated)</span><br><span class="line">        .bind(to: passwordOutlet.rx.isEnabled)</span><br><span class="line"></span><br><span class="line">    _ = usernameValid</span><br><span class="line">        .takeUntil(self.rx.deallocated)</span><br><span class="line">        .bind(to: usernameValidOutlet.rx.isHidden)</span><br><span class="line"></span><br><span class="line">    _ = passwordValid</span><br><span class="line">        .takeUntil(self.rx.deallocated)</span><br><span class="line">        .bind(to: passwordValidOutlet.rx.isHidden)</span><br><span class="line"></span><br><span class="line">    _ = everythingValid</span><br><span class="line">        .takeUntil(self.rx.deallocated)</span><br><span class="line">        .bind(to: doSomethingOutlet.rx.isEnabled)</span><br><span class="line"></span><br><span class="line">    _ = doSomethingOutlet.rx.tap</span><br><span class="line">        .takeUntil(self.rx.deallocated)</span><br><span class="line">        .subscribe(onNext: &#123; [weak self] in self?.showAlert() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将使得订阅一直持续到控制器的 dealloc 事件产生为止。</p>
<h1 id="Schedulers-调度器"><a href="#Schedulers-调度器" class="headerlink" title="Schedulers - 调度器"></a>Schedulers - 调度器</h1><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 后台取得数据，主线程处理结果</span><br><span class="line">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class="line">    let data = try? Data(contentsOf: url)</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        self.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rxData: Observable&lt;Data&gt; = ...</span><br><span class="line"></span><br><span class="line">rxData</span><br><span class="line">    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123; [weak self] data in</span><br><span class="line">        self?.data = data</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h2><p>我们用 subscribeOn 来决定数据序列的构建函数在哪个 Scheduler 上运行。以上例子中，由于获取 Data 需要花很长的时间，所以用 subscribeOn 切换到 后台 Scheduler 来获取 Data。这样可以避免主线程被阻塞。</p>
<h2 id="使用-observeOn"><a href="#使用-observeOn" class="headerlink" title="使用 observeOn"></a>使用 observeOn</h2><p>我们用 observeOn 来决定在哪个 Scheduler 监听这个数据序列。以上例子中，通过使用 observeOn 方法切换到主线程来监听并且处理结果。</p>
<p>一个比较典型的例子就是，在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn 切到后台去发送请求并解析数据，最后用 observeOn 切换到主线程更新页面。</p>
<ul>
<li>MainScheduler：MainScheduler 代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。</li>
<li>SerialDispatchQueueScheduler：SerialDispatchQueueScheduler 抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</li>
<li>ConcurrentDispatchQueueScheduler：ConcurrentDispatchQueueScheduler 抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</li>
<li>OperationQueueScheduler：OperationQueueScheduler 抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置 maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</li>
</ul>
<h1 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling - 错误处理"></a>Error Handling - 错误处理</h1><p>一旦序列里面产出了一个 error 事件，整个序列将被终止。RxSwift 主要有两种错误处理机制</p>
<h2 id="retry-重试"><a href="#retry-重试" class="headerlink" title="retry - 重试"></a>retry - 重试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 请求 JSON 失败时，立即重试，</span><br><span class="line">// 重试 3 次后仍然失败，就将错误抛出</span><br><span class="line"></span><br><span class="line">let rxJson: Observable&lt;JSON&gt; = ...</span><br><span class="line"></span><br><span class="line">rxJson</span><br><span class="line">    .retry(3)</span><br><span class="line">    .subscribe(onNext: &#123; json in</span><br><span class="line">        print(&quot;取得 JSON 成功: \(json)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;取得 JSON 失败: \(error)&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>如果我们需要在发生错误时，经过一段延时后重试，那可以用retryWhen：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 请求 JSON 失败时，等待 5 秒后重试，</span><br><span class="line">// 重试 4 次后仍然失败，就将错误抛出</span><br><span class="line"></span><br><span class="line">let maxRetryCount = 4       // 最多重试 4 次</span><br><span class="line">let retryDelay: Double = 5  // 重试延时 5 秒</span><br><span class="line"></span><br><span class="line">rxJson</span><br><span class="line">    .retryWhen &#123; (rxError: Observable&lt;Error&gt;) -&gt; Observable&lt;Int&gt; in</span><br><span class="line">        return rxError.flatMapWithIndex &#123; (error, index) -&gt; Observable&lt;Int&gt; in</span><br><span class="line">            guard index &lt; maxRetryCount else &#123;</span><br><span class="line">                return Observable.error(error)</span><br><span class="line">            &#125;</span><br><span class="line">            return Observable&lt;Int&gt;.timer(retryDelay, scheduler: MainScheduler.instance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(...)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>我们这里要实现的是，如果重试超过 4 次，就将错误抛出。如果错误在 4 次以内时，就等待 5 秒后重试，我们用 flatMapWithIndex 这个操作符，因为它可以给我们提供错误的索引数 index。然后用这个索引数判断是否超过最大重试数，如果超过了，就将错误抛出。如果没有超过，就等待 5 秒后重试。</p>
<h2 id="catchError-恢复"><a href="#catchError-恢复" class="headerlink" title="catchError - 恢复"></a>catchError - 恢复</h2><p>catchError 可以在错误产生时，用一个备用元素或者一组备用元素将错误替换掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">searchBar.rx.text.orEmpty</span><br><span class="line">    ...</span><br><span class="line">    .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in</span><br><span class="line">        ...</span><br><span class="line">        return searchGitHub(query)</span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    .bind(to: ...)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 当用户点击更新按钮时，</span><br><span class="line">// 就立即取出修改后的用户信息。</span><br><span class="line">// 然后发起网络请求，进行更新操作，</span><br><span class="line">// 一旦操作失败就提示用户失败原因</span><br><span class="line"></span><br><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; Observable&lt;Void&gt; in</span><br><span class="line">        return update(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        print(&quot;用户信息更新成功&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;用户信息更新失败： \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>这样实现是非常直接的。但是一旦网络请求操作失败了，序列就会终止。整个订阅将被取消。如果用户再次点击更新按钮，就无法再次发起网络请求进行更新操作了。</p>
<p>为了解决这个问题，我们需要选择合适的方案来进行错误处理。例如使用枚举 Result：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 自定义一个枚举类型 Result</span><br><span class="line">public enum Result&lt;T&gt; &#123;</span><br><span class="line">    case success(T)</span><br><span class="line">    case failure(Swift.Error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; Observable&lt;Result&lt;Void&gt;&gt; in</span><br><span class="line">        return update(userInfo)</span><br><span class="line">            .map(Result.success)  // 转换成 Result</span><br><span class="line">            .catchError &#123; error in Observable.just(Result.failure(error)) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123; result in</span><br><span class="line">        switch result &#123;           // 处理 Result</span><br><span class="line">        case .success:</span><br><span class="line">            print(&quot;用户信息更新成功&quot;)</span><br><span class="line">        case .failure(let error):</span><br><span class="line">            print(&quot;用户信息更新失败： \(error.localizedDescription)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>这样我们的错误事件被包装成了 Result.failure(Error) 元素，就不会终止整个序列。就算网络请求失败，整个订阅依然存在。如果用户再次点击更新按钮，也是能够发起网络请求进行更新操作的。</p>

    </div>
</article>


<div id="comments-template"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script>
	if(!window.commentConfig) {
      window.commentConfig = {}
      window.commentConfig.title = 'Fri Oct 20 2017 20:10:09 GMT+0800'
    }
</script>

                </div>
                <aside class="col-md-4 gal-left" id="sidebar">
    <!-- 此为sidebar的搜索框, 非搜索结果页面 -->
<aside id="sidebar-search">
    <div class="search hidden-xs" data-aos="fade-up" data-aos-duration="2000">
        <form class="form-inline clearfix" id="search-form" method="get"
              action="/search/index.html">
            <input type="text" name="s" class="form-control" id="searchInput" placeholder="搜索文章~">
            <button class="btn btn-danger btn-gal" type="submit">
                <i class="fa fa-search"></i>
            </button>
        </form>
    </div>
</aside>
    <aside id="sidebar-author">
    <div class="panel panel-gal" data-aos="flip-right" data-aos-duration="3000">
        <div class="panel-heading" style="text-align: center">
            <i class="fa fa-quote-left"></i>
            Levin Luo
            <i class="fa fa-quote-right"></i>
        </div>
        <div class="author-panel text-center">
            <img src="/imgs/avatar.jpg" width="140" height="140"
                 alt="个人头像" class="author-image">
            <p class="author-description"><p>Stay hungry、stay foolish.</p>
</p>
        </div>
    </div>
</aside>
    
    <!-- 要配置好leancloud才能开启此小工具 -->
    
    
    <aside id="sidebar-recent_posts">
    <div class="panel panel-gal recent hidden-xs" data-aos="fade-up" data-aos-duration="2000">
        <div class="panel-heading">
            <i class="fa fa-refresh"></i>
            近期文章
            <i class="fa fa-times-circle panel-remove"></i>
            <i class="fa fa-chevron-circle-up panel-toggle"></i>
        </div>
        <ul class="list-group list-group-flush">
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2018/03/23/快速定位目标控制器/">快速定位目标控制器</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2018/03/20/非著名不专业程序员必备工具/">非著名不专业程序员必备工具</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2018/03/18/iOS优质博客/">iOS优质博客</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/11/07/RxSwift操作符选择/">RxSwift操作符选择</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/11/03/RxSwift操作符/">RxSwift操作符</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/10/20/RxSwift核心概念/">RxSwift核心概念</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/10/14/iOS组件化/">路由协议</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/09/26/多线程使用/">多线程使用</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/09/15/多线程/">多线程</a>
                </span>
            </li>
            
            <li class="list-group-item">
                <span class="post-title">
                    <a href="/2017/08/11/runloop实践/">runloop实践</a>
                </span>
            </li>
            
        </ul>
    </div>
</aside>
    
    
    
    <aside id="gal-sets">
        <div class="panel panel-gal hidden-xs" data-aos="fade-up" data-aos-duration="2000">
            <ul class="nav nav-pills pills-gal">
                <li class="">
                    <a href="/2017/10/20/RxSwift核心概念/index.html#sidebar-tags" data-toggle="tab" id="tags-tab">热门标签</a>
                </li>
                <li class="">
                    <a href="/2017/10/20/RxSwift核心概念/index.html#sidebar-friend-links" data-toggle="tab" id="friend-links-tab">友情链接</a>
                </li>
                <li class="">
                    <a href="/2017/10/20/RxSwift核心概念/index.html#sidebar-links" data-toggle="tab" id="links-tab">个人链接</a>
                </li>
            </ul>
            <div class="tab-content">
                <div class="cloud-tags tab-pane nav bs-sidenav fade" id="sidebar-tags">
    
    <a href="/tags/RxSWift/" style="font-size: 14.98792960847205px;" class="tag-cloud-link">RxSWift</a>
    
    <a href="/tags/RxSwift/" style="font-size: 10.366830304101203px;" class="tag-cloud-link">RxSwift</a>
    
    <a href="/tags/UI篇/" style="font-size: 12.595355391806006px;" class="tag-cloud-link">UI篇</a>
    
    <a href="/tags/Tip/" style="font-size: 8.831470335768223px;" class="tag-cloud-link">Tip</a>
    
    <a href="/tags/iOS优质博客/" style="font-size: 15.620082077924982px;" class="tag-cloud-link">iOS优质博客</a>
    
    <a href="/tags/runloop/" style="font-size: 17.214127279817518px;" class="tag-cloud-link">runloop</a>
    
    <a href="/tags/runtime/" style="font-size: 18.388917561960007px;" class="tag-cloud-link">runtime</a>
    
    <a href="/tags/线程/" style="font-size: 15.343800293622401px;" class="tag-cloud-link">线程</a>
    
    <a href="/tags/工具篇/" style="font-size: 12.68572561899165px;" class="tag-cloud-link">工具篇</a>
    
</div>
                <div class="friend-links tab-pane nav bs-sidenav fade" id="sidebar-friend-links">
    
    <li>
        <a href="http://www.levinluo.com" target="_blank">Levin Luo</a>
    </li>
    
</div>
                <div class="links tab-pane nav bs-sidenav fade" id="sidebar-links">
    
    <li>
        <a href="http://www.levinluo.com" target="_blank">Levin Luo</a>
    </li>
    
</div>
            </div>
        </div>
    </aside>
    
</aside>
            </div>
        </div>
    </div>
    <footer id="gal-footer">
    <div class="container">
        Copyright © 2017 Levin Luo Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></a>
    </div>
</footer>

<!-- 回到顶端 -->
<div id="gal-gotop">
    <i class="fa fa-angle-up"></i>
</div>
</body>
<script src="/js/activate-power-mode.js"></script>
<script>
    // 配置highslide
  hs.graphicsDir = '/js/highslide/graphics/'
    hs.outlineType = "rounded-white";
    hs.dimmingOpacity = 0.8;
    hs.outlineWhileAnimating = true;
    hs.showCredits = false;
    hs.captionEval = "this.thumb.alt";
    hs.numberPosition = "caption";
    hs.align = "center";
    hs.transitions = ["expand", "crossfade"];
    hs.lang.number = '共%2张图, 当前是第%1张';
    hs.addSlideshow({
      interval: 5000,
      repeat: true,
      useControls: true,
      fixedControls: "fit",
      overlayOptions: {
        opacity: 0.75,
        position: "bottom center",
        hideOnMouseOut: true
      }
    })
    // 初始化aos
    AOS.init({
      duration: 1000,
      delay: 0,
      easing: 'ease-out-back'
    });
</script>
<script>
  POWERMODE.colorful = 'true';    // make power mode colorful
  POWERMODE.shake = 'true';       // turn off shake
  // TODO 这里根据具体情况修改
  document.body.addEventListener('input', POWERMODE);
</script>
<script>
    window.slideConfig = {
      prefix: '/imgs/slide/background',
      ext: 'jpg',
      maxCount: '6'
    }
</script>
<script src="/js/hs.js"></script>
<script src="/js/blog.js"></script>



<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    if(window.commentConfig) {
      window.commentConfig.id = 'Fri Oct 20 2017 20:10:09 GMT+0800'
      window.commentConfig.owner = 'PuShengLuo'
      window.commentConfig.repo = 'PuShengLuo.github.io'
      window.commentConfig.client_id = 'cc1a44fe73dbdbe0edb7'
      window.commentConfig.client_secret = 'b101ced75c5c8a67aff6dd02e85125eb775ffd1c'
      window.commentConfig.redirect_uri = ''
    } else {
      window.commentConfig = {
        id: 'Fri Oct 20 2017 20:10:09 GMT+0800',
        owner: 'PuShengLuo',
        repo: 'PuShengLuo.github.io',
        client_id: 'cc1a44fe73dbdbe0edb7',
        client_secret: 'b101ced75c5c8a67aff6dd02e85125eb775ffd1c',
        redirect_uri: ''
      }
    }
</script>
<script src="/js/comment/gitment.js"></script>

</html>