{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-19","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-19","excerpt":""}],"posts":[{"title":"路由协议","text":"","path":"2018/04/14/路由协议/","date":"04-14","excerpt":""},{"title":"非著名不专业程序员必备工具","text":"智能搜索工具Alfred 作为一名非著名不专业程序员，搜索几乎占据我们大部分时间。而这款软件可以堪称是利器，无论是谷歌百度还是快捷打开软件都可以大量节省我们时间。推荐 Alfred 插件：1. CodeVar : 可以让英文稀烂的你一样能写出一个标准英文变量名2. Kill Process: 快捷杀死程序 编程语言Api文档 Dash Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 接口调试工具 postman 引用官网一句话： Developers use Postman to build modern software for the API-first world. 代码管理可视化工具 SVN： 使用cornerstone Git: 使用Sourcetree Finder扩展工具 TotalFinder TotalFinder是mac搜索增强工具，具有多标签式浏览、拷贝路径、剪切文件、显示隐藏文件、双窗口模式等功能，让你浏览和搜索文件更加方便 MarkDown笔记编写工具 FaIcon 如果你像我一样比较懒不喜欢记MarkDown语法，那么就可以使用这款MarkDown 工具，内置常用语法标签按钮 邮件应用 Airmail 如果你像我一样喜欢根据个人习惯来定制应用，以求效率最大化的人，Airmail 高度的可定制性一定会让你欣喜若狂。只要你上手体验几分钟，你也会像我一样得出「Airmail 是现在 iOS 上可自定义程度最高的邮件应用」 强大的终端工具 ITerm2 如果你像我一样也喜欢搞些花里胡哨的界面，还可以配合oh-my-zsh插件做一些自定义配色方案 ~~~~最后送给大家两个Mac破解软件的网站大部分破解软件都能搜索到。精品MAC应用分享史蒂芬周的博客","path":"2018/03/20/非著名不专业程序员必备工具/","date":"03-20","excerpt":""},{"title":"runtime实践","text":"例题分析[self class]与[super class]1234567891011@implementation Son : Father- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125;return self;&#125;@end 运行结果： 122018-04-15 12:27:36.776910+0800 Runtime[2173:159137] Son2018-04-15 12:27:36.777059+0800 Runtime[2173:159137] Son 当调用[self class]时, 先调用的是 objc_msgSend 函数, 第一个参数是Son这个类的实例, 然后去示例的ISA(Son类)中找 - (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 而 - (Class)class 的实现就是返回self的类别, 故上述输出结果为 Son. 当调用[supe class]时, 先调用的是class_getSuperclass函数, 该函数第一个参数是结构体 objc_super(第一个参数是self, 第二个参数是当前实例变量的super_class, 就是Father类). 然后直接从实例变量所在类的父类(Father)去找- (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用, 此时已经和[self class]调用相同了, 故上述输出结果仍然返回 Son. isKindOfClass与isMemberOfClass1234567BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Father class] isKindOfClass:[Father class]];BOOL res4 = [[Father class] isMemberOfClass:[Father class]];NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); 结果： 12018-04-15 13:03:38.053683+0800 Runtime[2262:176716] 1 0 0 0 内部实现： 1234567891011121314151617181920212223242526272829+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj) &#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;- (BOOL)isKindOf:(Class)cls &#123; Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isMemberOf:(Class)cls &#123; return [self class] == cls;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125; res1：[NSObject class]返回NSObject,接着执行 + isKindOfClass, object_getClass((id)self)返回的是NSObject的isa 也就是NSObject 的meta class,所以第一次循环判断不等，第二次tcls = tcls-&gt;superclass也就是NSObject所以相等.结果为YES. res2：[NSObject class]返回NSObject,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO res3：[Father class]返回Father,接着执行 + isKindOfClass, object_getClass((id)self)返回的是Father的isa 也就是Father 的meta class,第二次tcls = tcls-&gt;superclass也就是NSObject的Meta Class,第三次是NSObject的Meta Class的superclass也就是NSObject,第四次是NSObject的superclass 为nil。退出循环，结果为NO. [Father class]返回Father,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO Category123456789101112131415161718下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface NSObject (Student) + (void)foo; - (void)foo; @end @implementation NSObject (Student) - (void)foo &#123; NSLog(@&quot;IMP: -[NSObject(Student) foo]&quot;); &#125;@end#import &quot;NSObject+Student.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; [NSObject foo]; [[NSObject new] foo]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 结果： 122018-04-16 17:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo]2018-04-16 17:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo] 分析：category中新增的方法, 如果是实例方法, 协议以及属性是直接添加到当前类上面, 如果是类方法和协议则会添加到当前类的原类上面去. 所以调用[NSObject foo]时, 由于是类方法, 根据objc_msgSend的相关知识, 会先在NSObject(Class)的isa中也就是NSObject的meta-class中, 去查找foo方法的IMP, 没找到, 然后去NSObject的meta-class的superclass(NSObject)中找, 找到了, 执行foo方法. 调用[[NSObject new] foo]时, 会先在NSObject(Object)的isa中, 也就是NSObject(Class)中找, 找到了, 直接执行, 输出结果. Runtime的常见用法Method SwizzlingMethod Swizzling本质上就是对IMP和SEL进行交换, 当Method Swilzzling代码执行完毕之后互换才起作用, Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式. 我们替换ViewController的viewWillAppear:方法为例, 使用方式如下: 123456789101112131415161718192021222324252627@implementation ViewController (MethodSwizzling)+ (void)load &#123; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; Class class = [self class]; //这里需要注意, 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //我们先把要替换的类添加到category中 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; //class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; //交换IMP, IMP是函数指针, 直接指向方法的内存地址 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@&quot;%@ viewWillAppear&quot;, self);&#125;@end 这里有几点是要注意的: Objective-C在运行时会自动调用类的两个方法+load和+initialize. +load会在类初始加载时调用, +initialize方法是以懒加载的方式被调用的, 只有当你给某个类或它的子类发送消息, 那么这个类的+initialize方法才会被调用. 所以Swizzling要写在+load方法中, 因为写在+initialize方法中, 是有可能永远都不被执行. Swizzling应该只被执行一次, 如果Swizzling的方法被多次执行, 那么就有可能造成Swizzling失效, 所以我们要用dispatch_once来保证只被执行一次. Swizzling在+load中执行时, 不要调用[super load]. 如果是多继承, 并且对同一个方法都进行了Swizzling, 那么调用[super load]以后, 父类的Swizzling就失效了. 在swizzling的过程中, 方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中. 这时不会产生无限循环. 如果我们调用的是[self viewWillAppear:animated], 因为viewWillAppear:被重定向到xxx_viewWillAppear:, 就会产生无限循环. 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. 我们也可以使用这个来做一些异常保护, 例如数组的越界问题, 我们可以Swizzling数组的objectAtIndex:方法, 在新方法中做一些异常处理, 来抛出一些异常信息, 方便我们定位问题. NSCoding的自动归档和自动解档主要思路是获取成员变量列表, 利用KVC读取和赋值来完成encodeWithCoder和initWithCoder. 123456789101112131415161718192021222324252627282930#import &quot;Student.h&quot;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation Student- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125;&#125;- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; return self;&#125;@end 参考资料： 神经病院 Objective-C Runtime 入院系列 Objective-C Runtime Objective-C Runtime 运行时系列 iOS 如何实现 Aspect Oriented Programming Method Swizzling 和 AOP 实践 刨根问底Objective－C Runtime 深入理解Objective-C：Category Objective-C 消息发送与转发机制原理","path":"2017/07/23/runtime实践/","date":"07-23","excerpt":""},{"title":"iOS中的runtime","text":"Objective-C是C的语言的超集,C是一门静态语言而Objective-C却是一门动态语言,这个动态特性就是由基于Smalltalk消息传递特性的Runtime来提供的.纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 Runtime简介Objective-C在三种层面上与Runtime系统进行交互: 通过 Objective-C 源代码Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码, 在运行时确定对应的数据结构和调用具体哪个方法. 通过 Foundation 框架的 NSObject 类定义的方法NSObject类是遵守NSObject协议的, 在这个协议里面有很多方法是和Runtime相关, 或者直接从Runtime中获取信息的. 通过对 Runtime 库函数的直接调用在这里需要注意一下, 系统本身是默认关闭了Runtime的代码提示的, 我们需要在BuildSettings -&gt; Enable Strict Checking objc_msgSend Calls -&gt;设置为NOObjective-C 的 Runtime 为我们提供了很多运行时状态下跟类与对象相关的函数,具体的可以看Objective-C Runtime Reference. Runtime 基础数据结构Object(对象), Class(类), Meta Class(原类), id. 通过objc_class的定义我们大致可以看出他们之间的关系: 12345678910111213141516171819202122232425typedef struct objc_class *Class; typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123; private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; id在Objective-C中可以代指任意的对象类型，他是一个指向objc_object结构体的指针（typedef struct objc_object *id;这个struct的定义本身就带了一个 , 所以我们在使用其他NSObject类型的实例时需要在前面加上 , 而使用 id 时却不用） 那么什么是 objc_object 呢? Objective-C中的Object(objc_object)在最后会被转换成C的结构体, 而在这个struct中有一个 isa_t 类型的结构体isa, 通过查看 isa_t 我们发现它里面有一个指向它的类别 Class(定义了对象所属的类). 注意: isa 指针不总是指向实例对象所属的类, 不能依靠它来确定类型, 而是应该用 class 方法来确定实例对象的类. 123456789101112struct objc_object &#123; private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor);&#125; 3.那么什么是 Class 呢? Class 其实是一个指向 objc_class 结构体的指针（typedef struct objc_class *Class;） 123456struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; 总结: Class在设计中本身也是一个对象. 而这个Class对象的对应的类, 我们叫它 Meta Class, 它用来表述类对象本身所具备的元数据, 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法. 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 即Class结构体中的 isa 指向的就是它的 Meta Class. 我们可以把Meta Class理解为一个Class对象的Class. 当我们给一个NSObject对象发送消息时(实例方法), 这条消息会在对象所属的类的方法列表里查找. 当我们发送一个消息给一个类时(类方法), 这条消息会在类的Meta Class的方法列表里查找. 下面这个图很好地说明了Object, Class, Meta Class之间的关系. 每个实例(Object)的isa指针都指向该实例所属的类. 每个类(Class)的isa指针都指向为一个该类所属的Meta Class(原类). 每个Meta Class(原类)的isa指针都指向Root Class(Meta)(根原类), 大部分情况是都是NSObject. Root class(meta)的superclass指向Root class(Class), 也就是NSObject, 形成一个回路. Root class(Class)其实就是NSObject, NSObject是没有超类的, 所以Root class(Class)的superclass指向nil. isa_tobjc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体. 因为 isa_t 使用 union 实现, 所以可能表示多种形态, 既可以当成是指针, 也可以存储标志位. 有关 isa_t 联合体的更多内容可以查看Objective-C 引用计数原理. 1234567union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; cache_tcache_t 出现在 objc_class 中, cache_t 中存储了一个 bucket_t 的结构体 _buckets ，和两个unsigned int 的变量 _mask 和 _occupied. _mask 分配用来缓存bucket的总数, _occupied 表明目前实际占用的缓存bucket的个数. bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP. IMP是一个函数指针, 指向了一个方法的具体实现. bucket_t *_buckets其实就是一个散列表, 用来存储Method的链表. Cache 的作用主要是为了优化方法调用的性能. 当对象receiver调用方法message时, 首先根据对象receiver 的 isa 指针查找到它对应的类, 然后在类的 methodLists 中搜索方法, 如果没有找到, 就使用 super_class 指针到父类中的 methodLists 查找, 一旦找到就调用方法. 如果没有找到, 有可能消息转发, 也可能忽略它. 但这样查找方式效率太低, 所以使用Cache来缓存经常调用的方法, 当调用方法时, 优先在Cache查找, 如果没有找到, 再到methodLists查找. 123456789101112131415161718192021222324//cache_t结构struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125; typedef unsigned int uint32_t; typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t; typedef uintptr_t cache_key_t; struct bucket_t &#123; private: cache_key_t _key; IMP _imp;public: inline cache_key_t key() const &#123; return _key; &#125; inline IMP imp() const &#123; return (IMP)_imp; &#125; inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125; inline void setImp(IMP newImp) &#123; _imp = newImp; &#125; void set(cache_key_t newKey, IMP newImp);&#125; class_data_bits_t1234567891011121314151617181920212223242526272829303132333435363738394041424344//class_data_bits_t结构struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125; struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125; struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 上面这张图很好地说明了 class_data_bits_t 的作用. 详见深入解析 ObjC 中方法的结构. 大致说明一下就是, Objc的类的属性, 方法, 以及遵循的协议在obj 2.0的版本之后都放在 class_rw_t 中. class_ro_t 是一个指向常量的指针, 存储来编译器决定了的属性、方法和遵守协议. 在运行时发消息时, 会从 class_data_bits_t 调用 data 方法, 将结果从 class_rw_t 强制转换为 class_ro_t 指针. 最后调用 methodizeClass 方法, 把类里面的属性, 协议, 方法都加载进来. 方法与消息SELSEL 又叫做方法选择器, 是表示一个方法的 selector 的指针, 定义如下: 1typedef struct objc_selector *SEL; OC在编译时，会依据每一个方法的名字，参数序列，生成一个唯一整形标识（Int类型的地址），这个标识就是SEL.不同类的不同方法，只要方法名相同，哪怕参数类型不同，这两个方法的SEL就是一样的.同一个类中就不能存在两个方法名一致，参数不一致，这样编译器就会报错.但不同的类就可以，因为不同类的实例对象执行方法时，是从各自类的方法列表中根据selector去寻找自己对应的IMP. 工程中所有的SEL组合成一个set集合，因此SEL是唯一的.set中的元素都是唯一的，所以SEL也是唯一的，所以我们找一个selector，通过他对应的SEL是最快的方法.SEL实际就是根据方法名Hash过的一个字符串（这也解释了上面相同方法名编译为什么报错的原因），字符串的比较只需比较地址就可以了，速度非常快.本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度 我们可以在运行时添加和获取selector，也可以通过下面几种方法来获取SEL: 1231. sel_registerName函数2. Objective-C编译器提供的@selector()3. NSSelectorFromString()方法 IMPIMP实际上是一个函数指针，指向方法实现的地址，定义如下 1id (*IMP)(id, SEL,...) 该函数的第一个参数是self的指针，如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针.第二个参数是方法选择器，后面是方法的参数列表. 每个方法对应唯一的SEL，我们通过SEL就是为了查找方法的最终实现IMP，而IMP这个函数指针指向了最终的方法实现，取得IMP后，我们就获得了执行这个方法代码的入口点.通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现.这样就省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些. 通过一组id和SEL参数就能确定唯一的方法实现地址，而一个确定的方法也只有唯一的一组id和SEL参数 MethodMethod用于表示类定义中的方法，定义如下： 12345678910111213struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 我们可以看到，该结构体包含name(方法名，本质是IMP)，types(方法类型，本质是个char指针，存储方法的参数类型和返回值)，imp（方法指向，本质是个IMP，也可以说是函数指针）.该结构体实际上相当于在SEL和IMP之间做了一个映射，让我们可以通过SEL快速找到IMP. 成员变量与属性IvarIvar用来表示实例变量，其实际是一个指向objc_ivar结构体的指针，定义如下： 12345678910111213typedef struct objc_ivar *Ivar;struct ivar_t &#123; int32_t *offset;//表示基地址偏移字节 const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; 我们对ivar的访问就可以通过 对象地址 + lvar偏移字节的方法来访问，但是如果增加了父类的lvar，那怎么办，OC使用Non Fragile Ivars机制，Runtime会进行检测来调整类中新增的ivar的偏移量，这样我们就可以通过 对象地址 + 基类大小 + lvar偏移字节的方法计算出对应的ivar地址，并访问到相应的ivar，而不用重新编译子类 我们无法通过 -&gt;函数来修改私有属性，但是我们可以通过对象地址 + lvar偏移量来访问地址，获取指针后直接修改 属性实际就是lvar加上系统自动为我们生成的get和set方法 objc_property_t@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针: 1typedef struct property_t *objc_property_t; 需要注意的是，与 class_copyIvarList 函数不同, 使用 class_copyPropertyList 函数只能获取类的属性, 而不包含成员变量, 但此时获取的属性名是不带下划线的. 更多姿势可以看这里. protocol_t12345678910111213141516struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; ... 省略一些封装的便捷 get 方法&#125; CategoryCategory(分类), 他为现有的类提供了扩展, 它是 category_t 结构体的指针.详细查看深入理解Objective-C：Category 123456789typedef struct category_t *Category;typedef struct category_t &#123; const char *name;//类的名字 classref_t cls;//类 struct method_list_t *instanceMethods;//category中所有给类添加的实例方法的列表 struct method_list_t *classMethods;//给所有类添加类方法的列表 struct protocol_list_t *protocols;//所有协议的列表 struct property_list_t *instanceProperties;//category中添加的所有属性的列表&#125; category_t; 从category的定义可以看出我们可以添加实例方法，类方法，甚至可以实现协议，添加属性，但是无法添加实例变量 在App的启动过程中，会在_read_images函数间接调用到attachCategories函数，完成向类中添加Category的工作，向class_rw_t中的method_array_t，property_array_t，protocol_array_t 数组中分别添加method_list_t，property_list_t，protocol_list_t指针.把category的实例方法, 协议以及属性添加到类上, 把category的类方法和协议添加到类的metaclass上. 我们需要注意的是： category不会覆盖原类中的方法，而是两个都存在，但是category的在前面，按照方法列表来找，找到category的之后, 就不再往下找了, 造成被覆盖的假象. 附加category的类的工作会先于+load方法的执行. +load的执行顺序是先类, 后category, 而category的+load执行顺序是根据编译顺序(Compile Sources中的顺序)决定的. 消息查找与转发Objective-C中任何方法的调用, 编译器都会将[receiver message]转化为一个消息函数的调用, 即objc_msgSend, 消息直到运行时才绑定到方法的实现上. objc_msgSend 的定义如下: 1objc_msgSend(receiver, selector, arg1, arg2, ...) 消息的查找和动态解析 判断 selector 是不是需要被忽略的垃圾回收用到的方法, 是的话就忽略, 不是的话继续下一步操作. 判断target是不是nil, 如果这里有相应的nil的处理函数, 就跳转到相应的函数中. 如果没有处理nil的函数, 就自动清理现场并返回. 这一点就是为何在OC中给nil发送消息不会崩溃的原因. 查找当前类的缓存, 如果命中缓存获取到了IMP就将IMP返回, 如果没有继续下一步操作. 在当前类的方法列表中查找(根据 selector 查找到 Method 后, 获取 Method 中的 IMP), 对已经排序的列表使用二分法查找, 未排序的列表则是线性遍历. 如果找到把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在继承层级中递归向父类(一直到 NSObject 为止)中查找, 情况跟上一步类似, 也是先查找缓存, 缓存没中就查找方法列表, 查到后就终止递归查询, 把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在消息查找阶段, 如果没找到IMP(也就是接收到未知的消息), 会进入动态方法解析阶段, 首先会调用所属类的+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)方法. 前提是我们必须自己实现该方法, 并且添加到类里面. 1234567891011void functionForMethod1(id self, SEL _cmd) &#123; NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125; + (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123; class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125; 此时如果既没有没查找到 IMP, 动态方法解析也不奏效, 那么就进入了下一个阶段-消息转发阶段. 消息的转发上面主要是消息的查找阶段主要完成的是通过select()快速查找IMP的过程, 接下来才是消息的转发阶段, 到了转发阶段, 会调用到了转发阶段, 会调用id _objc_msgForward(id self, SEL _cmd,…)方法. 在执行_objc_msgForward之后会调用 __objc_forward_handler函数. 它的实现大致如下: 12345678// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel) &#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self);&#125; 当我们给一个对象发送一个没有实现的方法的时候, 如果其父类也没有这个方法, 则会崩溃, 报错信息类似于这样: unrecognized selector sent to instance, 然后接着会跳出一些堆栈信息. 这些信息就是从这里而来. 如果上面的查找和解析都失败的话, 消息就会无法处理, 这是Runtime会调用以下方法: 1- (id)forwardingTargetForSelector:(SEL)aSelector 我们可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来把消息的接受者换成一个可以处理该消息的实例对象或者类对象. 示例如下: 12345678910111213- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(Method:))&#123; return otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@&quot;Class name&quot;); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果一个对象实现了这个方法, 并返回一个非nil的结果, 则这个对象会作为消息的新接收者, 且消息会被分发到这个对象.当然这个对象不能是self自身, 否则就是出现无限循环.如果我们没有指定相应的对象来处理aSelector, 则应该调用父类的实现来返回结果. 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上, 但这一步无法对消息进行处理, 如操作消息的参数和返回值. 如果在上一步还不能处理未知消息, 则唯一能做的就是启用完整的消息转发机制了. 运行时系统会给消息接收者最后一次机会将消息转发给其它对象. 我们首先要通过, 指定方法签名, 若返回nil, 则表示不处理. 123456- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123; return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector: aSelector];&#125; 若返回方法签名, 则会进入下一步调用. 12345678- (void)forwardInvovation:(NSInvocation)anInvocation &#123; if ([someOtherObject respondsToSelector: [anInvocation selector]]) &#123; [anInvocation invokeWithTarget:someOtherObject]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 该方法对象会创建一个表示消息的NSInvocation对象,把与尚未处理的消息有关的全部细节都封装在anInvocation中, 包括selector, 目标(target)和参数. 我们可以在forwardInvocation方法中选择将消息转发给其它对象. 我们可以通过anInvocation对象做很多处理, 比如修改实现方法, 修改响应对象等. 这个方法的主要作用是定位可以响应封装在anInvocation中的消息的对象(这个对象不需要能处理所有未知消息). 使用anInvocation作为参数, 将消息发送到选中的对象. anInvocation将会保留调用结果, 运行时系统会提取这一结果并将其发送到消息的原始发送者. 在这个方法中我们也可以实现一些更复杂的功能, 我们可以对消息的内容进行修改, 比如追回一个参数等, 然后再去触发消息. 另外, 若发现某个消息不应由本类处理, 则应调用父类的同名方法, 以便继承体系中的每个类都有机会处理此调用请求. 上面两个补救措施做完后, 若发现某调用不应由本类处理, 则会调用超类的同名方法. 如此, 继承体系中的每个类都有机会处理该方法调用的请求, 一直到NSObject根类. 如果到NSObject也不能处理该条消息, 那么就是再无挽救措施了, 只能抛出”doesNotRecognizeSelector”异常.","path":"2017/07/18/runtime/","date":"07-18","excerpt":""},{"title":"UICollectionView自定义布局","text":"当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就可以考虑自定义layout。 【必须】定制UICollectionViewLayout必须覆盖的方法123- (void)prepareLayout;- (CGSize)collectionViewContentSize;- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; prepareLayout是专门用来准备布局的，在prepareLayout方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。此方法在布局之前会调用一次，之后只有在调用invalidateLayout,shouldInvalidateLayoutForBoundsChange:返回YES和UICollectionView刷新的时候才会调用. collectionViewContentSize返回内容尺寸给UICollectionView.这个方法返回的尺寸是给UICollectionView这个继承于UIScrollView的视图作为contenSize,不是UICollectionView的视图尺寸.这个方法会多次调用，所以最好是在prepareLayout里就计算好。 layoutAttributesForElementsInRect方法返回一组UICollectionViewLayoutAttributes类对象.它代表着在这个指定的区域中，我们需要显示cell,Supplementary View 和 Decoration View中哪些视图，而这些视图的属性则保存UICollectionViewLayoutAttributes中.此方法会多次调用，为了更好的性能，在这个方法当中，我们使用的UICollectionViewLayoutAttributes最好是在prepareLayout已经布局好的信息。 【可选】交互定制方法12- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; shouldInvalidateLayoutForBoundsChange:当布局的边界发送改变的时候，会询问该方法是否重新布局.一旦重新刷新布局，就会按顺序调用下面的方法: prepareLayout,layoutAttributesForElementsInRect. targetContentOffsetForProposedContentOffset返回值决定collectionView在停止滚动的时候最终的偏移量contentOffset（常见的卡片布局会使用到） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)prepareLayout&#123; [super prepareLayout]; NSMutableArray *layoutInfoArr = [NSMutableArray array]; NSInteger maxNumberOfItems = 0; //获取布局信息 NSInteger numberOfSections = [self.collectionView numberOfSections]; for (NSInteger section = 0; section &lt; numberOfSections; section++)&#123; NSInteger numberOfItems = [self.collectionView numberOfItemsInSection:section]; NSMutableArray *subArr = [NSMutableArray arrayWithCapacity:numberOfItems]; for (NSInteger item = 0; item &lt; numberOfItems; item++)&#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section]; UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:indexPath]; [subArr addObject:attributes]; &#125; if(maxNumberOfItems &lt; numberOfItems)&#123; maxNumberOfItems = numberOfItems; &#125; //添加到二维数组 [layoutInfoArr addObject:[subArr copy]]; &#125; //存储布局信息 self.layoutInfoArr = [layoutInfoArr copy]; //保存内容尺寸 self.contentSize = CGSizeMake(maxNumberOfItems*(self.itemSize.width+self.interitemSpacing)+self.interitemSpacing, numberOfSections*(self.itemSize.height+self.lineSpacing)+self.lineSpacing);&#125;//itemSize是cell的大小，interitemSpacing是cell与cell之间的间距，lineSpacing是行距。- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //每一组cell为一行 attributes.frame = CGRectMake((self.itemSize.width+self.interitemSpacing)*indexPath.row+self.interitemSpacing, (self.itemSize.height+self.lineSpacing)*indexPath.section+self.lineSpacing, self.itemSize.width, self.itemSize.height); return attributes;&#125;- (CGSize)collectionViewContentSize&#123; return self.contentSize;&#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray *layoutAttributesArr = [NSMutableArray array]; [self.layoutInfoArr enumerateObjectsUsingBlock:^(NSArray *array, NSUInteger i, BOOL * _Nonnull stop) &#123; [array enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if(CGRectIntersectsRect(obj.frame, rect)) &#123; [layoutAttributesArr addObject:obj]; &#125; &#125;]; &#125;]; return layoutAttributesArr;&#125;","path":"2017/06/16/UICollectionView自定义布局/","date":"06-16","excerpt":""},{"title":"Cocoapods","text":"Cocoapods概念Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. Cocoapods的实现原理cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一Podfile. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。 Podfile source: spec的地址 platform: 指定构建静态库的平台 target: 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项 pod: 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的 执行完pod install 命令之后，可以发现工程里面多了三个文件, 一个XXX.xcworkspace文件, 一个Podfile.lock文件, 还有一个Pods文件夹. xcworkspace：管理新生成的Project和原本的Project Podfile.lock：记录各个Pod的版本号和之前的依赖关系 Pods： 新生成库的源代码 创建一个Spec RepoSpec Repo是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的: ├── Specs└── [SPEC_NAME]└── [VERSION]└── [SPEC_NAME].podspec如果你要创建私有Pod, 那么你的Spec Repo的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]来把远端的仓库clone到本地. 注意, 这里[Spec Repo的仓库名]不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交PodSpec文件时用到. 创建Pod工程文件我们在你需要创建Pod的目录下使用pod lib create [Pod名称]来创建对应的Pod模板. 实际上该命令行隐藏了默认参数, 参数补全后应该是pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git. 接下来会问你四个问题: What language do you want to use?? [ Swift / ObjC ]. 使用什么语言 Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架 Would you like to do view based testing? [ Yes / No ]. 是否基于View测试 What is your class prefix?. 类的前缀根据自己的实际需要来选择后, 就会自动执行Pod install命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:MyLib├── .travis.yml├── _Pods.xcproject├── Example│ ├── MyLib│ ├── MyLib.xcodeproj│ ├── MyLib.xcworkspace│ ├── Podfile│ ├── Podfile.lock│ ├── Pods│ └── Tests├── LICENSE├── MyLib.podspec├── Pod│ ├── Assets│ └── Classes│ └── RemoveMe.[swift/m]└── README.md接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库: 1234$ git add .$ git commit -s -m “Initial Commit of Library”$ git remote add origin [Pod的远端地址] #添加远端仓库$ git push origin master #提交到远端仓库 编辑Pod文件Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是Assets, 一个是Classes. Assets文件主要用来存放资源文件, 例如图片资源和XIB文件. Classes则存放主要的功能代码, 类.在这里需要注意两个地方: 当我们要使用Pod中的资源时, 以图片为例, 我们通过[UIImage imageWithName:@&quot;xxx.png&quot;]是取不到Pod中的图片的, 因为imageWithName:方法默认是从mainBundle中来取的, 而Pod不属于mainBundle的范畴, 我们需要先根据class来拿到当前类所在的bundle, 再取该Bundle中的资源. 每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行pod update命令来重新建立索引. 编辑Podspec文件初始时的Podspec文件包含了各种信息, 详细的说明我们可以看官方文档,这里贴上最基础的用法代码 123456789101112131415161718192021222324252627282930313233Pod::Spec.new do |s|s.name = ‘LevinPods’#Pod的版本s.version = ‘0.1.0’s.summary = ‘你在搜索时会呈现’s.description = &lt;&lt;-DESC这里是关于你Pod功能的描述DESCs.homepage = ‘https://github.com/HChong3210/HCPods‘s.license = &#123; :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ &#125;s.author = &#123; ‘LevinLuo’ =&gt; ‘786325209@qq.com’ &#125;#Pod的远端仓库地址s.source = &#123; :git =&gt; ‘https://github.com/xxx/LevinPods.git‘, :tag =&gt; s.version.to_s &#125;#Pod支持的最低版本s.ios.deployment_target = ‘8.0’#Pod源文件的位置s.source_files = ‘LevinPods/Classes/*/‘#Pod中资源文件的位置s.resource_bundles = &#123;‘DFCForms’ =&gt; [‘LevinPods/Assets/*.&#123;png,xib,plist&#125;’]&#125;#对外公开的类s.public_header_files = ‘DFCForms/Classes/*/.h’#Pod中用到的第三方库s.frameworks = ‘UIKit’s.dependency ‘AFNetworking’, ‘~&gt; 2.3’s.dependency ‘SDWebImage’end 提交Pod文件Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, 注意, 这里的Tag必须和Podspec文件中的Pod版本号一致 , 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码: 12345git statusgit add .git tag -m ‘备注’ 版本号git commit -s -m ‘备注’git push origin master —tags 提交Podspec文件提交完Pod文件后, 我们只用把Podspec文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了.在提交之前我们可以在根目录下使用pod lib lint命令来验证是否编译通过. 也可以直接提交pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose subspec的使用有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在Podspec文件中这样设置: 1234567s.subspec ‘[子Pod名称]’ do |pod1|pod1.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘ends.subspec ‘[子Pod名称]’ do |pod2|pod2.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘end 我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency. 我们在外面引用该Pod的时候就可以使用pod [Pod/子Pod]的方式来只引用一个子Pod. 常见Pod依赖的几种写法pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]pod ‘QueryKit/Attribute’pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’pod ‘AFNetworking’, :git =&gt; ‘https://github.com/gowalla/AFNetworking.git‘pod ‘JSONKit’, :podspec =&gt; ‘https://example.com/JSONKit.podspec‘ 参考资料 Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验 细聊Cocoapods与Xcode工程配置 使用Cocoapods创建私有podspec CocoaPods 都做了什么？ 使用私有Cocoapods仓库中引用.a库 深入理解CocoaPods","path":"2017/06/03/Cocoapods/","date":"06-03","excerpt":""},{"title":"iOS项目工程概念","text":"Xcode Workspaceworkspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件. 一个workspace可以管理多个Project,pod install的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project. Xcode Projectproject就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。 Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。 project包含了以下信息： 源文件 代码的头文件和实现文件 静态库，动态库 资源文件(如图片，文本，xml，plist等) 界面资源文件(xib， storyboard等) 在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹) project的编译级别配置文件如(debug， release) target 运行环境如：debug，test project可以单独存在，或者存在于一个workspace中. Xcode Targettarget 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product. 这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效. target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。 指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置. Scheme一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme. scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 Build Settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准 一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。 除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.关于继承关系，The Unofficial Guide to xcconfig files这里也有详细的说明，强烈建议阅读。动态环境配置就是使用自定义的 build settings 来实现的. 参考资料: Xcode使用xcconfig文件配置环境 Apple官方文档 Xcode中的Scheme和Build Configuration Xcode workSpace 多个project联编","path":"2017/05/11/iOS项目工程概念/","date":"05-11","excerpt":""},{"title":"Instruments使用","text":"Instruments 是 Xcode 提供我们调试App性能的分析工具 打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面 Core AnimationCore Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿. Color Blended Layers，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。 Color Hits Green and Misses Red，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。 Color Copied Images，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。 Color Non-Standard Surface Formats, 不标准的表面颜色格式. Color Immediately，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。 Color Misaligned Images，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。 Color Offscreen-Rendered Yellow，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。 Color Compositing Fast Path Blue，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。 Flash Updated Regions，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。 Leaks关于内存方面的监控, 有Leaks用来检测内存泄漏, Zombies用来检测僵尸对象. 关于内存泄漏常见的几种情况, 可以参考这里 Time Profiler这个主要是用来统计各个方法消耗的时间.如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的. Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Time Profiler无法定位到代码 Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File Profile要在debug模式下运行, BuildConfiguration要选择debug. 参考资料 iOS 性能优化：Instruments 工具的救命三招 Instruments性能优化-Core Animation 使用 Instruments 做 iOS 程序性能调试 关于内存泄漏，还有哪些是你不知道的？ 使用Instruments定位iOS应用的Memory Leaks instrument Time Profiler总结","path":"2017/04/28/Instruments使用/","date":"04-28","excerpt":""},{"title":"iOS内存分配","text":"计算机系统中，应用程序的数据都保存在内存中，不同的数据类型保存的区域也不同。 RAM和ROM RAM：运行时内存，程序在运行过程中的使用的内存，不能掉电存储 ROM：存储形内存（内存卡），RAM的速度和价格都高于ROM App程序启动，系统会把存储在ROM中的程序拷贝到RAM中，然后从内存里面执行代码 内存分区堆区：Heap堆区由程序员来分配(oc: alloc swift: init)和释放 ARC下的内存管理由编译器自动添加retain, release, autorelease等关键字 堆区的地址由低到高分配 不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理) 堆空间的分配总是动态的 需要程序猿进行分配和释放 栈区 Stack栈区是由编译器自动分配和释放的，用来存放局部变量，函数的参数值，函数跳转地址等iPhone栈区大小是512K 不需要我们管理栈区变量的内存 栈区地址从高到低分配 先进后出栈空间有静态分配和动态分配两种 静态分配是由编译器完成，比如自动变量auto的分配. 动态分配由alloca函数完成. 栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配. 全局区 static全局区也叫做静态区，全局变量和静态变量在内存中是存放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和静态变量放在相邻的宁一块区域，程序结束后由系统释放 常量区存放字符串常量，程序结束后由系统自己释放 代码区代码区用于存放函数的二进制代码，App的代码，程序结束后由系统释放 内存分区地址如图所示：代码区的地址最低，栈区最高，但区与区之间的地址不连续 栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便. 系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容). 变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回. 当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃. 申请内存后系统的响应 栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小. 堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去. 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.堆获得的空间比较灵活, 也比较大.","path":"2017/04/14/iOS内存分配/","date":"04-14","excerpt":""}]}