{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-19","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-19","excerpt":""}],"posts":[{"title":"非著名不专业程序员必备工具","text":"智能搜索工具Alfred 作为一名非著名不专业程序员，搜索几乎占据我们大部分时间。而这款软件可以堪称是利器，无论是谷歌百度还是快捷打开软件都可以大量节省我们时间。推荐 Alfred 插件：1. CodeVar : 可以让英文稀烂的你一样能写出一个标准英文变量名2. Kill Process: 快捷杀死程序 编程语言Api文档 Dash Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 接口调试工具 postman 引用官网一句话： Developers use Postman to build modern software for the API-first world. 代码管理可视化工具 SVN： 使用cornerstone Git: 使用Sourcetree Finder扩展工具 TotalFinder TotalFinder是mac搜索增强工具，具有多标签式浏览、拷贝路径、剪切文件、显示隐藏文件、双窗口模式等功能，让你浏览和搜索文件更加方便 MarkDown笔记编写工具 FaIcon 如果你像我一样比较懒不喜欢记MarkDown语法，那么就可以使用这款MarkDown 工具，内置常用语法标签按钮 邮件应用 Airmail 如果你像我一样喜欢根据个人习惯来定制应用，以求效率最大化的人，Airmail 高度的可定制性一定会让你欣喜若狂。只要你上手体验几分钟，你也会像我一样得出「Airmail 是现在 iOS 上可自定义程度最高的邮件应用」 强大的终端工具 ITerm2 如果你像我一样也喜欢搞些花里胡哨的界面，还可以配合oh-my-zsh插件做一些自定义配色方案 ~~~~最后送给大家两个Mac破解软件的网站大部分破解软件都能搜索到。精品MAC应用分享史蒂芬周的博客","path":"2018/03/20/非著名不专业程序员必备工具/","date":"03-20","excerpt":""},{"title":"Cocoapods","text":"Cocoapods概念Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. Cocoapods的实现原理cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一Podfile. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。 Podfile source: spec的地址 platform: 指定构建静态库的平台 target: 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项 pod: 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的 执行完pod install 命令之后，可以发现工程里面多了三个文件, 一个XXX.xcworkspace文件, 一个Podfile.lock文件, 还有一个Pods文件夹. xcworkspace：管理新生成的Project和原本的Project Podfile.lock：记录各个Pod的版本号和之前的依赖关系 Pods： 新生成库的源代码 创建一个Spec RepoSpec Repo是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的: ├── Specs└── [SPEC_NAME]└── [VERSION]└── [SPEC_NAME].podspec如果你要创建私有Pod, 那么你的Spec Repo的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]来把远端的仓库clone到本地. 注意, 这里[Spec Repo的仓库名]不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交PodSpec文件时用到. 创建Pod工程文件我们在你需要创建Pod的目录下使用pod lib create [Pod名称]来创建对应的Pod模板. 实际上该命令行隐藏了默认参数, 参数补全后应该是pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git. 接下来会问你四个问题: What language do you want to use?? [ Swift / ObjC ]. 使用什么语言 Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架 Would you like to do view based testing? [ Yes / No ]. 是否基于View测试 What is your class prefix?. 类的前缀根据自己的实际需要来选择后, 就会自动执行Pod install命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:MyLib├── .travis.yml├── _Pods.xcproject├── Example│ ├── MyLib│ ├── MyLib.xcodeproj│ ├── MyLib.xcworkspace│ ├── Podfile│ ├── Podfile.lock│ ├── Pods│ └── Tests├── LICENSE├── MyLib.podspec├── Pod│ ├── Assets│ └── Classes│ └── RemoveMe.[swift/m]└── README.md接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库: 1234$ git add .$ git commit -s -m “Initial Commit of Library”$ git remote add origin [Pod的远端地址] #添加远端仓库$ git push origin master #提交到远端仓库 编辑Pod文件Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是Assets, 一个是Classes. Assets文件主要用来存放资源文件, 例如图片资源和XIB文件. Classes则存放主要的功能代码, 类.在这里需要注意两个地方: 当我们要使用Pod中的资源时, 以图片为例, 我们通过[UIImage imageWithName:@&quot;xxx.png&quot;]是取不到Pod中的图片的, 因为imageWithName:方法默认是从mainBundle中来取的, 而Pod不属于mainBundle的范畴, 我们需要先根据class来拿到当前类所在的bundle, 再取该Bundle中的资源. 每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行pod update命令来重新建立索引. 编辑Podspec文件初始时的Podspec文件包含了各种信息, 详细的说明我们可以看官方文档,这里贴上最基础的用法代码 123456789101112131415161718192021222324252627282930313233Pod::Spec.new do |s|s.name = ‘LevinPods’#Pod的版本s.version = ‘0.1.0’s.summary = ‘你在搜索时会呈现’s.description = &lt;&lt;-DESC这里是关于你Pod功能的描述DESCs.homepage = ‘https://github.com/HChong3210/HCPods‘s.license = &#123; :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ &#125;s.author = &#123; ‘LevinLuo’ =&gt; ‘786325209@qq.com’ &#125;#Pod的远端仓库地址s.source = &#123; :git =&gt; ‘https://github.com/xxx/LevinPods.git‘, :tag =&gt; s.version.to_s &#125;#Pod支持的最低版本s.ios.deployment_target = ‘8.0’#Pod源文件的位置s.source_files = ‘LevinPods/Classes/*/‘#Pod中资源文件的位置s.resource_bundles = &#123;‘DFCForms’ =&gt; [‘LevinPods/Assets/*.&#123;png,xib,plist&#125;’]&#125;#对外公开的类s.public_header_files = ‘DFCForms/Classes/*/.h’#Pod中用到的第三方库s.frameworks = ‘UIKit’s.dependency ‘AFNetworking’, ‘~&gt; 2.3’s.dependency ‘SDWebImage’end 提交Pod文件Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, 注意, 这里的Tag必须和Podspec文件中的Pod版本号一致 , 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码: 12345git statusgit add .git tag -m ‘备注’ 版本号git commit -s -m ‘备注’git push origin master —tags 提交Podspec文件提交完Pod文件后, 我们只用把Podspec文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了.在提交之前我们可以在根目录下使用pod lib lint命令来验证是否编译通过. 也可以直接提交pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose subspec的使用有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在Podspec文件中这样设置: 1234567s.subspec ‘[子Pod名称]’ do |pod1|pod1.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘ends.subspec ‘[子Pod名称]’ do |pod2|pod2.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘end 我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency. 我们在外面引用该Pod的时候就可以使用pod [Pod/子Pod]的方式来只引用一个子Pod. 常见Pod依赖的几种写法pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]pod ‘QueryKit/Attribute’pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’pod ‘AFNetworking’, :git =&gt; ‘https://github.com/gowalla/AFNetworking.git‘pod ‘JSONKit’, :podspec =&gt; ‘https://example.com/JSONKit.podspec‘ 参考资料 Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验 细聊Cocoapods与Xcode工程配置 使用Cocoapods创建私有podspec CocoaPods 都做了什么？ 使用私有Cocoapods仓库中引用.a库 深入理解CocoaPods","path":"2017/06/03/Cocoapods/","date":"06-03","excerpt":""},{"title":"iOS项目工程概念","text":"Xcode Workspaceworkspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件. 一个workspace可以管理多个Project,pod install的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project. Xcode Projectproject就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。 Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。 project包含了以下信息： 源文件 代码的头文件和实现文件 静态库，动态库 资源文件(如图片，文本，xml，plist等) 界面资源文件(xib， storyboard等) 在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹) project的编译级别配置文件如(debug， release) target 运行环境如：debug，test project可以单独存在，或者存在于一个workspace中. Xcode Targettarget 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product. 这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效. target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。 指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置. Scheme一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme. scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 Build Settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准 一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。 除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.关于继承关系，The Unofficial Guide to xcconfig files这里也有详细的说明，强烈建议阅读。动态环境配置就是使用自定义的 build settings 来实现的. 参考资料: Xcode使用xcconfig文件配置环境 Apple官方文档 Xcode中的Scheme和Build Configuration Xcode workSpace 多个project联编","path":"2017/05/11/iOS项目工程概念/","date":"05-11","excerpt":""},{"title":"Instruments使用","text":"Instruments 是 Xcode 提供我们调试App性能的分析工具 打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面 Core AnimationCore Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿. Color Blended Layers，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。 Color Hits Green and Misses Red，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。 Color Copied Images，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。 Color Non-Standard Surface Formats, 不标准的表面颜色格式. Color Immediately，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。 Color Misaligned Images，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。 Color Offscreen-Rendered Yellow，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。 Color Compositing Fast Path Blue，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。 Flash Updated Regions，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。 Leaks关于内存方面的监控, 有Leaks用来检测内存泄漏, Zombies用来检测僵尸对象. 关于内存泄漏常见的几种情况, 可以参考这里 Time Profiler这个主要是用来统计各个方法消耗的时间.如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的. Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Time Profiler无法定位到代码 Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File Profile要在debug模式下运行, BuildConfiguration要选择debug. 参考资料 iOS 性能优化：Instruments 工具的救命三招 Instruments性能优化-Core Animation 使用 Instruments 做 iOS 程序性能调试 关于内存泄漏，还有哪些是你不知道的？ 使用Instruments定位iOS应用的Memory Leaks instrument Time Profiler总结","path":"2017/04/28/Instruments使用/","date":"04-28","excerpt":""},{"title":"iOS内存分配","text":"计算机系统中，应用程序的数据都保存在内存中，不同的数据类型保存的区域也不同。 RAM和ROM RAM：运行时内存，程序在运行过程中的使用的内存，不能掉电存储 ROM：存储形内存（内存卡），RAM的速度和价格都高于ROM App程序启动，系统会把存储在ROM中的程序拷贝到RAM中，然后从内存里面执行代码 内存分区堆区：Heap堆区由程序员来分配(oc: alloc swift: init)和释放 ARC下的内存管理由编译器自动添加retain, release, autorelease等关键字 堆区的地址由低到高分配 不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理) 堆空间的分配总是动态的 需要程序猿进行分配和释放 栈区 Stack栈区是由编译器自动分配和释放的，用来存放局部变量，函数的参数值，函数跳转地址等iPhone栈区大小是512K 不需要我们管理栈区变量的内存 栈区地址从高到低分配 先进后出栈空间有静态分配和动态分配两种 静态分配是由编译器完成，比如自动变量auto的分配. 动态分配由alloca函数完成. 栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配. 全局区 static全局区也叫做静态区，全局变量和静态变量在内存中是存放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和静态变量放在相邻的宁一块区域，程序结束后由系统释放 常量区存放字符串常量，程序结束后由系统自己释放 代码区代码区用于存放函数的二进制代码，App的代码，程序结束后由系统释放 内存分区地址如图所示：代码区的地址最低，栈区最高，但区与区之间的地址不连续 栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便. 系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容). 变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回. 当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃. 申请内存后系统的响应 栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小. 堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去. 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.堆获得的空间比较灵活, 也比较大.","path":"2017/04/14/page/","date":"04-14","excerpt":""}]}