{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-19","excerpt":""},{"title":"非著名不专业程序员","text":"一个开朗上进的iOS开发工作者,对苹果设计理念的认同和对编程的兴趣让我选择了iOS开发这个行业,对待工作有责任,有担当.保证工作及时并高效完成,并能从过往的经历中总结经验不断的完善自己.闲暇时喜欢从cocoachina和github中寻找一些有意思的Demo和新技术来充电,也喜欢看看闲书.永远保持好奇心. Stay hungry. Stay foolish.","path":"about/index.html","date":"05-14","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-19","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"05-14","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"05-14","excerpt":""}],"posts":[{"title":"ITunes12.7以后导出商店IPA包","text":"由于ITunes12.7以后取消了下载应用的功能导致不能下载IPA包到本地.网上也提供了降级ITunes的方法来达到下载IPA包的目的，但是降级之后我这边ITunes也是各种报错,应该是苹果爸爸对低版本的ITunes采取了某些措施. 首先我们先去mac 应用商店 下载一个Apple Configurator,然后登录自己的Apple账户,选择自己的设备,点击添加,选择应用（这里只能选择手机上已经按照的应用）,选择自己需要IPA的应用.这个时候就开始下载应用了,应用下载完之后会弹出一个已经存在应用,这个时候什么都不要点 直接去下面这个文件夹就能找到IPA包了.~/资源库/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 最后把IPA包复制出来,然后点击弹出上的停止,你就可以看到上面文件夹的IPA包消失了…","path":"2018/05/17/ITunes12-7以后导出商店IPA包/","date":"05-17","excerpt":""},{"title":"iOS性能优化","text":"卡顿优化通常来说,计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的.CPU 计算好显示内容提交到 GPU,GPU 渲染完成后将渲染结果放入帧缓冲区,随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据,经过可能的数模转换传递给显示器显示. iOS 保持界面流畅的技巧 编译优化增加XCode执行的线程数XCode默认使用与CPU核数相同的线程来进行编译, 但由于编译过程中的IO操作往往比CPU运算要多, 因此适当的提升线程数可以在一定程度上加快编译速度. 在终端输入defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES开启多线程, 更改线程数设置defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 5. 将Debug Information Format改为DWARF将Target-&gt;Build Settings中, 找到Debug Information Format这一项, 将Debug时的DWARF with dSYM file改为DWARF. 这一项设置的是是否将调试信息加入到可执行文件中, 改为DWARF后, 如果程序崩溃, 将无法输出崩溃位置对应的函数堆栈, 但由于Debug模式下可以在XCode中查看调试信息, 所以改为DWARF影响并不大. 这一项更改完之后, 可以大幅提升编译速度.将Debug Information Format改为DWARF之后, 会导致在Debug窗口无法查看相关类类型的成员变量的值. 当需要查看这些值时, 可以将Debug Information Format改回DWARF with dSYM file, clean(必须)之后重新编译. 将Build Active Architecture Only改为Yes将Target-&gt;Build Settings中, 找到Build Active Architecture Only这一项, 将Debug时的 NO 改为 YES. 需要注意的是, 此选项在Release模式下必须为NO, 否则发布的ipa在部分设备上将不能运行. 这一项更改完之后, 可以显著提高编译速度. 设计编译优化等级不要再项目中或者静态库中使用-O4, 因为这会让Clang链接Link Time Optimizations (LTO)使得编译更慢, 通常使用-O3. 在设置编译优化之后, XCode断点和调试信息会不正常, 所以一般静态库或者其他Target这样设置. 将常用的代码及文件打包成静态库我们用Cocoapods来管理第三方包, 我们可以将第三方包打包成静态库, 也可以提升编译速度. 也可以将第三方包打包成二进制文件, 但是这样不方便调试. 启动优化App总启动时间 = t1(main()之前的加载时间) + t2(main()之后的加载时间).t1 = 系统dylib(动态链接库)和自身App可执行文件的加载;t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication )Application didFinishLaunchingWithOptions:(NSDictionary )launchOptions方法执行结束前这段时间, 主要是构建第一个界面, 并完成渲染展示. 今日头条iOS客户端启动速度优化 瘦身优化资源瘦身资源瘦身主要是去掉无用资源和压缩资源, 资源包括图片, 音视频文件, 配置文件以及多语言wording. 资源压缩主要对png进行无损压缩. 编译选项优化 Optimization Level 使用Fastest, Smalllest. 该选项对安装包大小影响几无，但可以提高app的性能 Strip Linked Product 设置为YES, 需要注意的是Strip Linked Product也受到Deployment Postprocessing设置选项的影响. 在Build Settings中, 我们可以看到， Strip Linked Product是在Deployment这栏中的, 而Deployment Postprocessing相当于是Deployment的总开关. 记得把Deployment Postprocessing也设置为YES. Symbols Hidden by Default设置为YES Make Strings Read-Only 设置为YES 二进制安装包二进制包是由各种代码文件, 静态库 动态库 经过编译后生成的可执行文件. XCode开启编译选项Write Link Map File XCode -&gt; target -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes, 并指定好linkMap的存储位置. 编译后到编译目录里找到该txt文件, 文件名和路径就是上述的Path to Link Map File.~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/. 这个LinkMap里展示了整个可执行文件的全貌, 列出了编译后的每一个.o目标文件的信息(包括静态链接库.a里的), 以及每一个目标文件的代码段, 数据段存储详情. 到https://github.com/huanxsd/LinkMap下载这个mac工程, 然后运行, 对文件进行分析. 通过对上面的文件进行分析, 就知道每个类在最终的可执行文件中占据的大小. 然后有针对性的进行优化就可以了. 删除一些无用文件查找无用selector, 无用OC类, 扫描重复代码.","path":"2018/05/15/iOS性能优化/","date":"05-15","excerpt":""},{"title":"快速定位目标控制器","text":"接手一个老项目或项目目录结构复杂的时候，我们要修改某个控制器的界面/功能时，控制器的定位就有些许困难。 充分条件: Xcode 9.0 及以上 模拟器/真机 iOS 11.0 及以上 过程: 模拟器/真机定位需要调试的界面 定位到 debug 工具 -&gt; 点击 debug view hierarchies 轻转一下视图层次,就可以看到整个的页面的层次结构,今天的重点在这里,控制器实例 点击控制器实例(上图红框部分),看 Xcode 右侧 show the object inspector","path":"2018/03/23/快速定位目标控制器/","date":"03-23","excerpt":""},{"title":"非著名不专业程序员必备工具","text":"智能搜索工具Alfred 作为一名非著名不专业程序员，搜索几乎占据我们大部分时间。而这款软件可以堪称是利器，无论是谷歌百度还是快捷打开软件都可以大量节省我们时间。推荐 Alfred 插件：1. CodeVar : 可以让英文稀烂的你一样能写出一个标准英文变量名2. Kill Process: 快捷杀死程序 编程语言Api文档 Dash Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 接口调试工具 postman 引用官网一句话： Developers use Postman to build modern software for the API-first world. 代码管理可视化工具 SVN： 使用cornerstone Git: 使用Sourcetree Finder扩展工具 TotalFinder TotalFinder是mac搜索增强工具，具有多标签式浏览、拷贝路径、剪切文件、显示隐藏文件、双窗口模式等功能，让你浏览和搜索文件更加方便 MarkDown笔记编写工具 FaIcon 如果你像我一样比较懒不喜欢记MarkDown语法，那么就可以使用这款MarkDown 工具，内置常用语法标签按钮 邮件应用 Airmail 如果你像我一样喜欢根据个人习惯来定制应用，以求效率最大化的人，Airmail 高度的可定制性一定会让你欣喜若狂。只要你上手体验几分钟，你也会像我一样得出「Airmail 是现在 iOS 上可自定义程度最高的邮件应用」 强大的终端工具 ITerm2 如果你像我一样也喜欢搞些花里胡哨的界面，还可以配合oh-my-zsh插件做一些自定义配色方案 ~~~~最后送给大家两个Mac破解软件的网站大部分破解软件都能搜索到。精品MAC应用分享史蒂芬周的博客","path":"2018/03/20/非著名不专业程序员必备工具/","date":"03-20","excerpt":""},{"title":"iOS优质博客","text":"高质量 iOS 博客推荐","path":"2018/03/18/iOS优质博客/","date":"03-18","excerpt":""},{"title":"RxSwift+HandyJson+Moya优雅实现网络请求","text":"首先在podfile文件中导入需要用到的库 12pod &apos;Moya/RxSwift&apos;pod &apos;HandyJSON&apos; 因为Moya/RxSwift中包含了RxSwift所以不必再导入RxSwift库,Moya和HandyJSON库的使用这里就不介绍了. 1234567891011121314151617&#123; &quot;code&quot;: 10000, &quot;msg&quot;: &quot;&quot;, &quot;tips&quot;: &quot;&quot;, &quot;data&quot;: &#123;&#125;&#125;&#123; &quot;code&quot;: 10000, &quot;msg&quot;: &quot;&quot;, &quot;tips&quot;: &quot;&quot;, &quot;data&quot;: &#123; &quot;total_page&quot;: 1, &quot;list&quot;: [ ] &#125;&#125; 上面是我们服务端约定返回的两种json格式. 12345678910111213141516171819202122232425262728293031323334353637383940414243import UIKitimport HandyJSONenum RxSwiftMoyaError: Error &#123; case RxSwiftMoyaNoRepresentor case RxSwiftMoyaNotSuccessfulHTTP case RxSwiftMoyaNoData case RxSwiftMoyaCouldNotMakeObjectError case RxSwiftMoyaBizError(resultCode: Int?, resultMsg: String?) case RXSwiftMoyaNoNetwork&#125;public class BaseModel&lt;T: HandyJSON&gt;: HandyJSON &#123; var code: UInt? var msg: String? var tips: String? var data: T? var success: Bool &#123; guard let cd = code, cd == 10000 else &#123; return false &#125; return true &#125; required public init() &#123;&#125; &#125;public class BaseListModel&lt;T: HandyJSON&gt;: HandyJSON &#123; var total_page: UInt? var list: [T]? required public init() &#123;&#125;&#125; 上面是根据json返回的格式定义的BaseModel和网络请求的错误枚举 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import Foundationimport RxSwiftimport Moyaimport HandyJSONimport Alamofireextension ObservableType where E == Response &#123; public func mapBaseModel&lt;T: HandyJSON&gt;(_ type: T.Type ) -&gt; Observable&lt;BaseModel&lt;T&gt;&gt; &#123; return flatMap &#123; response -&gt; Observable&lt;BaseModel&lt;T&gt;&gt; in let ele: BaseModel&lt;T&gt; = try response.mapBaseModel(T.self) return Observable.just(ele) &#125; &#125; public func mapBaseModelArray&lt;T: HandyJSON&gt;(_ type: T.Type ) -&gt; Observable&lt;BaseModel&lt;BaseListModel&lt;T&gt;&gt;&gt; &#123; return flatMap &#123; response -&gt; Observable&lt;BaseModel&lt;BaseListModel&lt;T&gt;&gt;&gt; in return Observable.just(try response.mapBaseModelArray(T.self)) &#125; &#125;&#125;extension Response &#123; func mapBaseModel&lt;T: HandyJSON&gt;(_ type: T.Type) throws -&gt; BaseModel&lt;T&gt; &#123; // check http status guard -1001 != self.statusCode else &#123; throw RxSwiftMoyaError.RXSwiftMoyaNoNetwork &#125; guard ((200...209) ~= self.statusCode) else &#123; throw RxSwiftMoyaError.RxSwiftMoyaNotSuccessfulHTTP &#125; let jsonString = String.init(data: data, encoding: .utf8) let baseModel = JSONDeserializer&lt;BaseModel&lt;T&gt;&gt;.deserializeFrom(json: jsonString) guard let model = baseModel else &#123; throw RxSwiftMoyaError.RxSwiftMoyaCouldNotMakeObjectError &#125; guard model.success else&#123; throw RxSwiftMoyaError.RxSwiftMoyaBizError(resultCode:model.code,resultMsg:model.msg) &#125; guard (model.data != nil) else &#123; throw RxSwiftMoyaError.RxSwiftMoyaNoData &#125; return model &#125; func mapBaseModelArray&lt;T: HandyJSON&gt;(_ type: T.Type) throws -&gt; BaseModel&lt;BaseListModel&lt;T&gt;&gt; &#123; // check http status guard -1001 != self.statusCode else &#123; throw RxSwiftMoyaError.RXSwiftMoyaNoNetwork &#125; guard ((200...209) ~= self.statusCode) else &#123; throw RxSwiftMoyaError.RxSwiftMoyaNotSuccessfulHTTP &#125; let jsonString = String.init(data: data, encoding: .utf8) guard let baseModel = JSONDeserializer&lt;BaseModel&lt;BaseListModel&lt;T&gt;&gt;&gt;.deserializeFrom(json: jsonString) else &#123; throw RxSwiftMoyaError.RxSwiftMoyaCouldNotMakeObjectError &#125; guard baseModel.success else&#123; throw RxSwiftMoyaError.RxSwiftMoyaBizError(resultCode:baseModel.code,resultMsg:baseModel.msg) &#125; guard let count = baseModel.data?.list?.count,count &gt; 0 else &#123; throw RxSwiftMoyaError.RxSwiftMoyaNoData &#125; return baseModel &#125;&#125; 使用： 1234567891011121314151617181920212223242526272829provider.request(.api()).mapBaseModelArray(apiModel.self).subscribe( onNext: &#123; model in //这里面的model是baseModel //model -&gt; data -&gt; list 是个 apiModel数组 //如果将mapBaseModelArray改为mapBaseModel,那么 model -&gt; data 就是apiModel &#125;, onError: &#123; error in let myError: RxSwiftMoyaError? = error as? RxSwiftMoyaError guard let err = myError else &#123; print(error.localizedDescription) return &#125; switch err &#123; case .RxSwiftMoyaNoData: debugPrint(&quot;no data&quot;) case .RxSwiftMoyaBizError( _,let resultMsg): debugPrint(&quot;\\(String(describing: resultMsg))&quot;) case .RXSwiftMoyaNoNetwork: //没有网络的情况下 debugPrint(&quot;没有网络&quot;) default: print(err) &#125; &#125; ).addDisposableTo(self.dispose) 需要注意的是provider要使用RxMoyaProvider定义","path":"2017/12/15/RxSwift-HandyJson-Moya优雅实现网络请求/","date":"12-15","excerpt":""},{"title":"RxSwift操作符选择","text":"我想要创建一个 Observable产生特定的一个元素：just 经过一段延时：timer从一个序列拉取元素：from重复的产生某一个元素：repeatElement存在自定义逻辑：create每次订阅时产生：deferred每隔一段时间，发出一个元素：interval一个空序列，只有一个完成事件：empty一个任何事件都没有产生的序列：never 创建组合其他的 Observables任意一个 Observable 产生了元素，就发出这个元素：merge让这些 Observables 一个接一个的发出元素，当上一个 Observable 元素发送完毕后，下一个 Observable 才能开始发出元素：concat组合每一个 Observable 然后发出一个组合的新元素：zip当任意一个 Observable 发出一个新的元素：combineLatest 转换 Observable 的元素后，再将它们发出来对每个元素直接转换：map转换到另一个 Observable：flatMap只接收最新的元素转换的 Observable 所产生的元素：flatMapLatest每一个元素转换的 Observable 按顺序产生元素：concatMap基于所有遍历过的元素： scan 我想要将产生的每一个元素，拖延一段时间后再发出：delay 我想要将产生的事件封装成元素发送出来将他们封装成 Event：materialize，然后解封出来：dematerialize 我想要忽略掉所有的 next 事件，只接收 completed 和 error 事件：ignoreElements 我想创建一个新的 Observable 在原有的序列前面加入一些元素：startWith 我想从 Observable 中收集元素，缓存这些元素之后在发出：buffer 我想将 Observable 拆分成多个 Observables：window基于元素的共同特征：groupBy 我想只接收 Observable 中特定的元素发出唯一的元素：single 我想重新从 Observable 中发出某些元素通过判定条件过滤出一些元素：filter仅仅发出头几个元素：take仅仅发出尾部的几个元素：takeLast仅仅发出第 n 个元素：elementAt 跳过头几个元素跳过头 n 个元素：skip跳过头几个满足判定的元素：skipWhile，skipWhileWithIndex跳过某段时间内产生的头几个元素：skip跳过头几个元素直到另一个 Observable 发出一个元素：skipUntil 只取头几个元素只取头几个满足判定的元素：takeWhile，takeWhileWithIndex只取某段时间内产生的头几个元素：take只取头几个元素直到另一个 Observable 发出一个元素：takeUntil周期性的对 Observable 抽样：sample发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：debounce直到元素的值发生变化，才发出新的元素：distinctUntilChanged并提供元素是否相等的判定函数：distinctUntilChanged在开始发出元素时，延时后进行订阅：delaySubscription 我想要从一些 Observables 中，只取第一个产生元素的 Observable：amb 我想评估 Observable 的全部元素并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：reduce并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：scan 我想把 Observable 转换为其他的数据结构：as… 我想在某个 Scheduler 应用操作符：subscribeOn在某个 Scheduler 监听：observeOn 我想要 Observable 发生某个事件时, 采取某个行动：do 我想要 Observable 发出一个 error 事件：error如果规定时间内没有产生元素：timeout 我想要 Observable 发生错误时，优雅的恢复如果规定时间内没有产生元素，就切换到备选 Observable ：timeout如果产生错误，将错误替换成某个元素 ：catchErrorJustReturn如果产生错误，就切换到备选 Observable ：catchError如果产生错误，就重试 ：retry 我创建一个 Disposable 资源，使它与 Observable 具有相同的寿命：using 我创建一个 Observable，直到我通知它可以产生元素后，才能产生元素：publish并且，就算是在产生元素后订阅，也要发出全部元素：replay并且，一旦所有观察者取消观察，他就被释放掉：refCount通知它可以产生元素了：connect","path":"2017/11/07/RxSwift操作符选择/","date":"11-07","excerpt":""},{"title":"RxSwift操作符","text":"amb当你传入多个 Observables 到 amb 操作符时，它将取其中一个 Observable：第一个产生事件的那个 Observable，可以是一个 next，error 或者 completed 事件. amb 将忽略掉其他的 Observables. 123456789101112131415161718192021222324 let subject1 = PublishSubject&lt;Int&gt;() let subject2 = PublishSubject&lt;Int&gt;() let subject3 = PublishSubject&lt;Int&gt;() subject1 .amb(subject2) .amb(subject3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject2.onNext(1) subject1.onNext(20) subject2.onNext(2) subject1.onNext(40) subject3.onNext(0) subject2.onNext(3) subject1.onNext(60) subject3.onNext(0) subject3.onNext(0)运行结果：123 buffer缓存元素，然后将缓存的元素集合，周期性的发出来.buffer 操作符将缓存 Observable 中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。 1234567891011121314151617181920212223 let subject = PublishSubject&lt;String&gt;() //每缓存3个元素则组合起来一起发出。 //如果1秒钟内不够3个也会发出（有几个发几个，一个都没有发空数组 []） subject .buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject.onNext(&quot;a&quot;) subject.onNext(&quot;b&quot;) subject.onNext(&quot;c&quot;) subject.onNext(&quot;1&quot;) subject.onNext(&quot;2&quot;) subject.onNext(&quot;3&quot;)运行结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;][&quot;1&quot;, &quot;2&quot;, &quot;3&quot;][][][] catchErrorcatchError 操作符将会拦截一个 error 事件，将它替换成其他的元素或者一组元素，然后传递给观察者。这样可以使得 Observable 正常结束，或者根本都不需要结束。 123456789101112131415161718192021222324252627282930313233enum TestError: Error &#123; case test&#125; let sequenceThatFails = PublishSubject&lt;String&gt;() let recoverySequence = PublishSubject&lt;String&gt;() sequenceThatFails .catchError &#123; print(&quot;Error:&quot;, $0) return recoverySequence &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) sequenceThatFails.onNext(&quot;1&quot;) sequenceThatFails.onNext(&quot;2&quot;) sequenceThatFails.onNext(&quot;3&quot;) sequenceThatFails.onError(TestError.test） sequenceThatFails.onNext(&quot;4&quot;) recoverySequence.onNext(&quot;a&quot;) recoverySequence.onNext(&quot;b&quot;) recoverySequence.onNext(&quot;c&quot;)运行结果：next(1)next(2)next(3)Error: testnext(a)next(b)next(c) catchErrorJustReturncatchErrorJustReturn 操作符会将error 事件替换成其他的一个元素，然后结束该序列。 1234567891011121314151617 let sequenceThatFails = PublishSubject&lt;String&gt;() sequenceThatFails .catchErrorJustReturn(&quot;tihuan&quot;) .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) sequenceThatFails.onNext(&quot;1&quot;) sequenceThatFails.onNext(&quot;2&quot;) sequenceThatFails.onError(TestError.test) sequenceThatFails.onNext(&quot;3&quot;)运行结果：next(1)next(2)next(tihuan)completed combineLatestcombineLatest 操作符将多个 Observables 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源 Observables 中任何一个发出一个元素，他都会发出一个元素（前提是，这些 Observables 曾经发出过元素. 123456789101112131415161718192021222324 let first = PublishSubject&lt;String&gt;() let second = PublishSubject&lt;String&gt;() Observable.combineLatest(first, second) &#123; $0 + $1 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) first.onNext(&quot;1&quot;) second.onNext(&quot;A&quot;) first.onNext(&quot;2&quot;) second.onNext(&quot;B&quot;) second.onNext(&quot;C&quot;) second.onNext(&quot;D&quot;) first.onNext(&quot;3&quot;) first.onNext(&quot;4&quot;)运行结果:1A2A2B2C2D3D4D concatconcat 操作符将多个 Observables 按顺序串联起来，当前一个 Observable 元素发送完毕后，后一个 Observable 才可以开始发出元素。 1234567891011121314151617181920212223242526272829let subject1 = BehaviorSubject(value: &quot;🍎&quot;) let subject2 = BehaviorSubject(value: &quot;🐶&quot;) let variable = Variable(subject1) variable.asObservable() .concat() .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) subject1.onNext(&quot;🍐&quot;) subject1.onNext(&quot;🍊&quot;) variable.value = subject2 subject2.onNext(&quot;I would be ignored&quot;) subject2.onNext(&quot;🐱&quot;) subject1.onCompleted() subject2.onNext(&quot;🐭&quot;)运行结果:next(🍎)next(🍐)next(🍊)next(🐱)next(🐭) concatMapconcatMap 操作符将源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。然后让这些 Observables 按顺序的发出元素，当前一个 Observable 元素发送完毕后，后一个 Observable 才可以开始发出元素。等待前一个 Observable 产生完成事件后，才对后一个 Observable 进行订阅。 12345678910111213141516171819202122232425262728let subject1 = BehaviorSubject(value: &quot;🍎&quot;)let subject2 = BehaviorSubject(value: &quot;🐶&quot;)let variable = Variable(subject1)variable.asObservable() .concatMap &#123; $0 &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)subject1.onNext(&quot;🍐&quot;)subject1.onNext(&quot;🍊&quot;)variable.value = subject2subject2.onNext(&quot;I would be ignored&quot;)subject2.onNext(&quot;🐱&quot;)subject1.onCompleted()subject2.onNext(&quot;🐭&quot;)运行结果:next(🍎)next(🍐)next(🍊)next(🐱)next(🐭) connect通知 ConnectableObservable 可以开始发出元素了,ConnectableObservable 和普通的 Observable 十分相似，不过在被订阅后不会发出元素，直到 connect 操作符被应用为止。这样一来你可以等所有观察者全部订阅完成后，才发出元素。 123456789101112131415161718192021222324252627282930313233343536373839let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .publish()_ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \\($0)&quot;) &#125;)DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; _ = intSequence.connect()&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 4) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \\($0)&quot;) &#125;)&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 6) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \\($0)&quot;) &#125;)&#125;运行结果:Subscription 1:, Event: 0Subscription 1:, Event: 1Subscription 2:, Event: 1Subscription 1:, Event: 2Subscription 2:, Event: 2Subscription 1:, Event: 3Subscription 2:, Event: 3Subscription 3:, Event: 3Subscription 1:, Event: 4Subscription 2:, Event: 4Subscription 3:, Event: 4Subscription 1:, Event: 5Subscription 2:, Event: 5Subscription 3:, Event: 5Subscription 1:, Event: 6Subscription 2:, Event: 6Subscription 3:, Event: 6... create通过一个构建函数完整的创建一个 Observable 123456789101112131415//创建一个 [0, 1, ... 8, 9] 的序列：let id = Observable&lt;Int&gt;.create &#123; observer in observer.onNext(0) observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onNext(4) observer.onNext(5) observer.onNext(6) observer.onNext(7) observer.onNext(8) observer.onNext(9) observer.onCompleted() return Disposables.create()&#125; debouncedebounce 操作符将发出这种元素，在 Observable 产生这种元素后，一段时间内没有新元素产生。 123456789101112131415161718 let intSequence = PublishSubject&lt;Int&gt;() intSequence.debounce(4, scheduler: MainScheduler.instance).subscribe &#123; print($0) &#125; .disposed(by: disposeBag) DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; intSequence.onNext(1) &#125; DispatchQueue.main.asyncAfter(deadline: .now() + 4) &#123; intSequence.onNext(2) &#125; DispatchQueue.main.asyncAfter(deadline: .now() + 6) &#123; intSequence.onNext(3) &#125; &#125;运行结果:next(3) debug打印所有的订阅，事件以及销毁信息 123456789101112131415161718 let sequence = Observable&lt;String&gt;.create &#123; observer in observer.onNext(&quot;🍎&quot;) observer.onNext(&quot;🍐&quot;) observer.onCompleted() return Disposables.create() &#125; sequence .debug(&quot;Fruit&quot;) .subscribe() .disposed(by: disposeBag)运行结果:2017-11-04 10:20:36.519: Fruit -&gt; subscribed2017-11-04 10:20:36.527: Fruit -&gt; Event next(🍎)2017-11-04 10:20:36.528: Fruit -&gt; Event next(🍐)2017-11-04 10:20:36.528: Fruit -&gt; Event completed2017-11-04 10:20:36.528: Fruit -&gt; isDisposed deferreddeferred 操作符将等待观察者订阅它，才创建一个 Observable，它会通过一个构建函数为每一位订阅者创建新的 Observable。看上去每位订阅者都是对同一个 Observable 产生订阅，实际上它们都获得了独立的序列。 delaydelay 操作符将修改一个 Observable，它会将 Observable 的所有元素都拖延一段设定好的时间， 然后才将它们发送出来。 delaySubscriptiondelaySubscription 操作符将在经过所设定的时间后，才对 Observable 进行订阅操作。 dematerializedematerialize 操作符将 materialize 转换后的元素还原 1234567891011121314151617181920 //materialize 该操作符可以将序列产生的事件，转换成元素 Observable.of(1, 2, 3) .materialize() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) Observable.of(1, 2, 3) .materialize() .dematerialize() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:next(1)next(2)next(3)completed123 distinctUntilChangeddistinctUntilChanged 操作符将阻止 Observable 发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。 1234567891011Observable.of(&quot;🐱&quot;, &quot;🐷&quot;, &quot;🐱&quot;, &quot;🐱&quot;, &quot;🐱&quot;, &quot;🐵&quot;, &quot;🐱&quot;) .distinctUntilChanged() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:🐱🐷🐱🐵🐱 do当 Observable 的某些事件产生时，你可以使用 do 操作符来注册一些回调操作。这些回调会被单独调用，它们会和 Observable 原本的回调分离。 elementAtelementAt 操作符将拉取 Observable 序列中指定索引数的元素，然后将它作为唯一的元素发出。 1234567Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;) .elementAt(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:🐸 emptyempty 操作符将创建一个 Observable，这个 Observable 只有一个完成事件。 errorerror 操作符将创建一个 Observable，这个 Observable 只会产生一个 error 事件。 filterfilter 操作符将通过你提供的判定方法过滤一个 Observable。 123456789Observable.of(2, 30, 22, 5, 60, 1) .filter &#123; $0 &gt; 10 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:302260 flatMapflatMap 操作符将源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。 然后将这些 Observables 的元素合并之后再发送出来。这个操作符是非常有用的，例如，当 Observable 的元素本身拥有其他的 Observable 时，你可以将所有子 Observables 的元素发送出来。 123456789101112131415161718192021let subject1 = BehaviorSubject(value: &quot;A&quot;) let subject2 = BehaviorSubject(value: &quot;1&quot;) let variable = Variable(subject1) variable.asObservable() .flatMap &#123; $0 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject1.onNext(&quot;B&quot;) variable.value = subject2 subject2.onNext(&quot;2&quot;) subject1.onNext(&quot;C&quot;) 运行结果:AB12C flatMapLatestflatMapLatest 操作符将源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。一旦转换出一个新的 Observable，就只发出它的元素，旧的 Observables 的元素将被忽略掉。 1234567891011121314151617181920let subject1 = BehaviorSubject(value: &quot;A&quot;)let subject2 = BehaviorSubject(value: &quot;1&quot;) let variable = Variable(subject1) variable.asObservable() .flatMapLatest &#123; $0 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject1.onNext(&quot;B&quot;)variable.value = subject2subject2.onNext(&quot;2&quot;)subject1.onNext(&quot;C&quot;)运行结果:AB12 from当你在使用 Observable 时，如果能够直接将其他类型转换为 Observable，这将是非常省事的。from 操作符就提供了这种功能。 1let numbers = Observable.from([0, 1, 2]) groupBygroupBy 操作符将源 Observable 分解为多个子 Observable，然后将这些子 Observable 发送出来。它会将元素通过某个键进行分组，然后将分组后的元素序列以 Observable 的形态发送出来。 1234567891011121314151617//将奇数偶数分成两组Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5) .groupBy(keySelector: &#123; (element) -&gt; String in return element % 2 == 0 ? &quot;偶数&quot; : &quot;基数&quot; &#125;) .subscribe &#123; (event) in switch event &#123; case .next(let group): group.asObservable().subscribe(&#123; (event) in print(&quot;key：\\(group.key) event：\\(event)&quot;) &#125;) .disposed(by: self.disposeBag) default: print(&quot;&quot;) &#125; &#125; .disposed(by: disposeBag) ignoreElementsignoreElements 操作符将阻止 Observable 发出 next 事件，但是允许他发出 error 或 completed 事件。 intervalinterval 操作符将创建一个 Observable，它每隔一段设定的时间，发出一个索引数的元素。它将发出无数个元素。 justust 操作符将某一个元素转换为 Observable。 mapmap 操作符将源 Observable 的每个元素应用你提供的转换方法，然后返回含有转换结果的 Observable。 123456789Observable.of(1, 2, 3) .map &#123; $0 * 10 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:102030 merge通过使用 merge 操作符你可以将多个 Observables 合并成一个，当某一个 Observable 发出一个元素时，他就将这个元素发出。 123456789101112131415161718192021222324252627let subject1 = PublishSubject&lt;String&gt;()let subject2 = PublishSubject&lt;String&gt;()Observable.of(subject1, subject2) .merge() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)subject1.onNext(&quot;🅰️&quot;)subject1.onNext(&quot;🅱️&quot;)subject2.onNext(&quot;①&quot;)subject2.onNext(&quot;②&quot;)subject1.onNext(&quot;🆎&quot;)subject2.onNext(&quot;③&quot;)运行结果:🅰️🅱️①②🆎③ materialize通常，一个有限的 Observable 将产生零个或者多个 onNext 事件，然后产生一个 onCompleted 或者 onError 事件。materialize 操作符将 Observable 产生的这些事件全部转换成元素，然后发送出来。 nevernever 操作符将创建一个 Observable，这个 Observable 不会产生任何事件。 observeOnobserveOn 操作符将指定一个不同的 Scheduler 来让 Observable 通知观察者。 publishpublish 会将 Observable 转换为可被连接的 Observable。可被连接的 Observable 和普通的 Observable 十分相似，不过在被订阅后不会发出元素，直到 connect 操作符被应用为止。这样一来你可以控制 Observable 在什么时候开始发出元素。 123456789101112131415161718192021222324252627282930313233343536373839let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .publish()_ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \\($0)&quot;) &#125;)DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; _ = intSequence.connect()&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 4) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \\($0)&quot;) &#125;)&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 6) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \\($0)&quot;) &#125;)&#125;输出结果:Subscription 1:, Event: 0Subscription 1:, Event: 1Subscription 2:, Event: 1Subscription 1:, Event: 2Subscription 2:, Event: 2Subscription 1:, Event: 3Subscription 2:, Event: 3Subscription 3:, Event: 3Subscription 1:, Event: 4Subscription 2:, Event: 4Subscription 3:, Event: 4Subscription 1:, Event: 5Subscription 2:, Event: 5Subscription 3:, Event: 5Subscription 1:, Event: 6Subscription 2:, Event: 6Subscription 3:, Event: 6... reducereduce 操作符将对第一个元素应用一个函数。然后，将结果作为参数填入到第二个元素的应用函数中。以此类推，直到遍历完全部的元素后发出最终结果。 123456789let disposeBag = DisposeBag()Observable.of(10, 100, 1000) .reduce(1, accumulator: +) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:1111 refCountrefCount 操作符将自动连接和断开可被连接的 Observable。它将可被连接的 Observable 转换为普通 Observable。当第一个观察者对它订阅时，那么底层的 Observable 将被连接。当最后一个观察者离开时，那么底层的 Observable 将被断开连接。 repeatElementepeatElement 操作符将创建一个 Observable，这个 Observable 将无止尽的发出同一个元素。 replayreplay 操作符将 Observable 转换为可被连接的 Observable，并且这个可被连接的 Observable 将缓存最新的 n 个元素。当有新的观察者对它进行订阅时，它就把这些被缓存的元素发送给观察者。 123456789101112131415161718192021222324252627282930313233343536373839404142let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .replay(5)_ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \\($0)&quot;) &#125;)DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; _ = intSequence.connect()&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 4) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \\($0)&quot;) &#125;)&#125;DispatchQueue.main.asyncAfter(deadline: .now() + 8) &#123; _ = intSequence .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \\($0)&quot;) &#125;)&#125;输出结果:Subscription 1:, Event: 0Subscription 2:, Event: 0Subscription 1:, Event: 1Subscription 2:, Event: 1Subscription 1:, Event: 2Subscription 2:, Event: 2Subscription 1:, Event: 3Subscription 2:, Event: 3Subscription 1:, Event: 4Subscription 2:, Event: 4Subscription 3:, Event: 0Subscription 3:, Event: 1Subscription 3:, Event: 2Subscription 3:, Event: 3Subscription 3:, Event: 4Subscription 1:, Event: 5Subscription 2:, Event: 5Subscription 3:, Event: 5Subscription 1:, Event: 6Subscription 2:, Event: 6Subscription 3:, Event: 6... retryretry 操作符将不会将 error 事件，传递给观察者，然而，它会从新订阅源 Observable，给这个 Observable 一个重试的机会，让它有机会不产生 error 事件。retry 总是对观察者发出 next 事件，即便源序列产生了一个 error 事件，所以这样可能会产生重复的元素。 123456789101112131415161718192021222324252627282930313233343536var count = 1let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in observer.onNext(&quot;🍎&quot;) observer.onNext(&quot;🍐&quot;) observer.onNext(&quot;🍊&quot;) if count == 1 &#123; observer.onError(TestError.test) print(&quot;Error encountered&quot;) count += 1 &#125; observer.onNext(&quot;🐶&quot;) observer.onNext(&quot;🐱&quot;) observer.onNext(&quot;🐭&quot;) observer.onCompleted() return Disposables.create()&#125;sequenceThatErrors .retry() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:🍎🍐🍊Error encountered🍎🍐🍊🐶🐱🐭 samplesample 操作符将不定期的对源 Observable 进行取样操作。通过第二个 Observable 来控制取样时机。一旦第二个 Observable 发出一个元素，就从源 Observable 中取出最后产生的元素。 scanscan 操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。 1234567891011Observable.of(10, 100, 1000) .scan(1) &#123; aggregateValue, newValue in aggregateValue + newValue &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:111111111 shareReplayshareReplay 操作符将使得观察者共享源 Observable，并且缓存最新的 n 个元素，将这些元素直接发送给新的观察者。 singlesingle 操作符将限制 Observable 只产生一个元素。如果 Observable 只有一个元素，它将镜像这个 Observable 。如果 Observable 没有元素或者元素数量大于一，它将产生一个 error 事件。 skipskip 操作符可以让你跳过 Observable 中头 n 个元素，只关注后面的元素。 12345678910Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;) .skip(2) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:🐶🐸🐷🐵 skipUntilskipUntil 操作符可以让你忽略源 Observable 中头几个元素，直到另一个 Observable 发出一个元素后，它才镜像源 Observable。 12345678910111213141516171819202122let sourceSequence = PublishSubject&lt;String&gt;()let referenceSequence = PublishSubject&lt;String&gt;()sourceSequence .skipUntil(referenceSequence) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)sourceSequence.onNext(&quot;🐱&quot;)sourceSequence.onNext(&quot;🐰&quot;)sourceSequence.onNext(&quot;🐶&quot;)referenceSequence.onNext(&quot;🔴&quot;)sourceSequence.onNext(&quot;🐸&quot;)sourceSequence.onNext(&quot;🐷&quot;)sourceSequence.onNext(&quot;🐵&quot;)输出结果:🐸🐷🐵 skipWhileskipWhile 操作符可以让你忽略源 Observable 中头几个元素，直到元素的判定为否后，它才镜像源 Observable。 12345678910Observable.of(1, 2, 3, 4, 3, 2, 1) .skipWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:4321 startWithstartWith 操作符会在 Observable 头部插入一些元素。（如果你想在尾部加入一些元素可以用concat） 1234567891011121314151617Observable.of(&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;) .startWith(&quot;1&quot;) .startWith(&quot;2&quot;) .startWith(&quot;3&quot;, &quot;🅰️&quot;, &quot;🅱️&quot;) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)输出结果:3🅰️🅱️21🐶🐱🐭🐹 subscribeOn指定 Observable 在那个 Scheduler 执行 take通过 take 操作符你可以只发出头 n 个元素。并且忽略掉后面的元素，直接结束序列。 123456789Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;) .take(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:🐱🐰🐶 takeLast通过 takeLast 操作符你可以只发出尾部 n 个元素。并且忽略掉前面的元素 123456789Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;) .takeLast(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:🐸🐷🐵 takeUntiltakeUntil 操作符将镜像源 Observable，它同时观测第二个 Observable。一旦第二个 Observable 发出一个元素或者产生一个终止事件，那个镜像的 Observable 将立即终止。 1234567891011121314151617181920212223let sourceSequence = PublishSubject&lt;String&gt;()let referenceSequence = PublishSubject&lt;String&gt;()sourceSequence .takeUntil(referenceSequence) .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)sourceSequence.onNext(&quot;🐱&quot;)sourceSequence.onNext(&quot;🐰&quot;)sourceSequence.onNext(&quot;🐶&quot;)referenceSequence.onNext(&quot;🔴&quot;)sourceSequence.onNext(&quot;🐸&quot;)sourceSequence.onNext(&quot;🐷&quot;)sourceSequence.onNext(&quot;🐵&quot;)运行结果:next(🐱)next(🐰)next(🐶)completed takeWhiletakeWhile 操作符将镜像源 Observable 直到某个元素的判定为 false。此时，这个镜像的 Observable 将立即终止。 123456789Observable.of(1, 2, 3, 4, 3, 2, 1) .takeWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)运行结果:123 timeout如果 Observable 在一段时间内没有产生元素，timeout 操作符将使它发出一个 error 事件。 timertimer 操作符将创建一个 Observable，它在经过设定的一段时间后，产生唯一的一个元素。 using通过使用 using 操作符创建 Observable 时，同时创建一个可被清除的资源，一旦 Observable 终止了，那么这个资源就会被清除掉了。 windowwindow 操作符和 buffer 十分相似，buffer 周期性的将缓存的元素集合发送出来，而 window 周期性的将元素集合以 Observable 的形态发送出来。buffer 要等到元素搜集完毕后，才会发出元素序列。而 window 可以实时发出元素序列。 withLatestFromwithLatestFrom 操作符将两个 Observables 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个 Observable 发出一个元素时，就立即取出第二个 Observable 中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。 123456789101112131415161718192021222324252627282930313233let firstSubject = PublishSubject&lt;String&gt;()let secondSubject = PublishSubject&lt;String&gt;()firstSubject .withLatestFrom(secondSubject) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)firstSubject.onNext(&quot;🅰️&quot;)firstSubject.onNext(&quot;🅱️&quot;)secondSubject.onNext(&quot;1&quot;)secondSubject.onNext(&quot;2&quot;)firstSubject.onNext(&quot;🆎&quot;)输出结果:2firstSubject .withLatestFrom(secondSubject) &#123; (first, second) in return first + second &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)firstSubject.onNext(&quot;🅰️&quot;)firstSubject.onNext(&quot;🅱️&quot;)secondSubject.onNext(&quot;1&quot;)secondSubject.onNext(&quot;2&quot;)firstSubject.onNext(&quot;🆎&quot;)输出结果:🆎2 zipzip 操作符将多个(最多不超过8个) Observables 的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的 Observable 的第一个元素，是由每一个源 Observables 的第一个元素组合出来的。它的第二个元素 ，是由每一个源 Observables 的第二个元素组合出来的。它的第三个元素 ，是由每一个源 Observables 的第三个元素组合出来的，以此类推。它的元素数量等于源 Observables 中元素数量最少的那个。 123456789101112131415161718192021let first = PublishSubject&lt;String&gt;()let second = PublishSubject&lt;String&gt;()Observable.zip(first, second) &#123; $0 + $1 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)first.onNext(&quot;1&quot;)second.onNext(&quot;A&quot;)first.onNext(&quot;2&quot;)second.onNext(&quot;B&quot;)second.onNext(&quot;C&quot;)second.onNext(&quot;D&quot;)first.onNext(&quot;3&quot;)first.onNext(&quot;4&quot;)输出结果:1A2B3C4D","path":"2017/11/03/RxSwift操作符/","date":"11-03","excerpt":""},{"title":"RxSwift核心概念","text":"RxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发，维护。RxSwift的作用是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程. 链式编程通过高阶函数以点为连接将多个函数连接在一起完成参数传递和复杂的操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152enum MyError: Error &#123; case DivZero // 除数为0&#125;class Calculate: NSObject &#123; class func ts_calculate(make: (Calculate) -&gt; Void) &#123; let calculate = Calculate() make(calculate) print(calculate.result) &#125; //保存计算结果 var result: Float = 0.0 //加 func add(num: Float) -&gt; Calculate &#123; result += num return self &#125; //减 func sub(num: Float) -&gt; Calculate &#123; result -= num return self &#125; //乘 func mul(num: Float) -&gt; Calculate &#123; result *= num return self &#125; //除 func div(num: Float) throws -&gt; Calculate &#123; guard num != 0 else&#123; throw MyError.DivZero &#125; result /= num return self &#125;&#125;//使用 Calculate.ts_calculate &#123; (make) in make.add(num: 6).sub(num: 2).mul(num: 5) do &#123; try make.div(num: 0) &#125;catch &#123; print(error) &#125; &#125; 响应式编程响应式编程根源于 FRP（函数响应式编程）命令驱动的编程方式，是以异步数据流的形式进行编程。 1234567var B = 20let C = A * 2 + B// 当前值// A = 10, B = 20, C = 40A = 0// 当前值// A = 0, B = 20, C = 40 在这里把a,b,c当成某个状态，c是a,b两个状态的组合，正常的编程中，在计算了c的状态之后，再去改变a,b的状态是不会影响到c的状态的。所以在正常编程中我们要去记录很多状态并及时更新状态，比如网络请求的状态，下拉刷新的状态。各种各样的事件响应方式，无形中增加了编码的复杂度。而在响应式编程中，每一个状态的改变都会发出一个信号，更新与之关联的状态。 一般可使用弹珠图来展示这个原理。如下图所示，每一行表示连续的一段时间，每一个弹珠表示发生在特定时刻的一个事件。 Observable - 可被监听的序列Observable也就是一个被观察的对象，是一个事件序列，订阅者可以订阅它，监测事件的发生(Next\\Complete\\Error) .onNext(element) 表示新的事件数据。 .onError(error) 表示事件序列因异常而完结。 .onCompleted() 表示事件序列完结。 创建序列1234567891011121314151617181920212223242526let numbers: Observable&lt;Int&gt; = Observable.create &#123; observer -&gt; Disposable in observer.onNext(0) observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onNext(4) observer.onNext(5) observer.onNext(6) observer.onNext(7) observer.onNext(8) observer.onNext(9) observer.onCompleted() return Disposables.create()&#125;numbers .subscribe(onNext: &#123; num in print(&quot;取得 num 成功: \\(num)&quot;) &#125;, onError: &#123; error in print(&quot;取得 num 失败 Error: \\(error.localizedDescription)&quot;) &#125;, onCompleted: &#123; print(&quot;取得 num 任务成功完成&quot;) &#125;) .disposed(by: disposeBag) 特征序列RxSwift 里面 Observable 也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码 SingleSingle 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能发出一个元素，要么产生一个 error 事件。 一个比较常见的例子就是执行 HTTP 请求，然后返回一个应答或错误。不过你也可以用 Single 来描述任何只有一个元素的序列,不共享状态变化.也可以对 Observable 调用 .asSingle() 方法，将它转换为 Single 1234567891011121314151617181920212223242526272829303132333435func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123; return Single&lt;[String: Any]&gt;.create &#123; single in let url = URL(string: &quot;https://api.github.com/repos/\\(repo)&quot;)! let task = URLSession.shared.dataTask(with: url) &#123; data, _, error in if let error = error &#123; single(.error(error)) return &#125; guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves), let result = json as? [String: Any] else &#123; single(.error(DataError.cantParseJSON)) return &#125; single(.success(result)) &#125; task.resume() return Disposables.create &#123; task.cancel() &#125; &#125;&#125;getRepo(&quot;ReactiveX/RxSwift&quot;) .subscribe(onSuccess: &#123; json in print(&quot;JSON: &quot;, json) &#125;, onError: &#123; error in print(&quot;Error: &quot;, error) &#125;) .disposed(by: disposeBag) CompletableCompletable 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能产生一个 completed 事件，要么产生一个 error 事件,不共享状态变化. Completable 适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 Observable 有点相似。 1234567891011121314151617181920212223func cacheLocally() -&gt; Completable &#123; return Completable.create &#123; completable in // Store some data locally ... ... guard success else &#123; completable(.error(CacheError.failedCaching)) return Disposables.create &#123;&#125; &#125; completable(.completed) return Disposables.create &#123;&#125; &#125;&#125;cacheLocally() .subscribe(onCompleted: &#123; print(&quot;Completed with no error&quot;) &#125;, onError: &#123; error in print(&quot;Completed with an error: \\(error.localizedDescription)&quot;) &#125;) .disposed(by: disposeBag) MaybeMaybe 是 Observable 的另外一个版本。它介于 Single 和 Completable 之间，它要么只能发出一个元素，要么产生一个 completed 事件，要么产生一个 error 事件,不共享状态变化.可以对 Observable 调用 .asMaybe() 方法，将它转换为 Maybe。 12345678910111213141516171819202122232425func generateString() -&gt; Maybe&lt;String&gt; &#123; return Maybe&lt;String&gt;.create &#123; maybe in maybe(.success(&quot;RxSwift&quot;)) // OR maybe(.completed) // OR maybe(.error(error)) return Disposables.create &#123;&#125; &#125;&#125;generateString() .subscribe(onSuccess: &#123; element in print(&quot;Completed with element \\(element)&quot;) &#125;, onError: &#123; error in print(&quot;Completed with an error \\(error.localizedDescription)&quot;) &#125;, onCompleted: &#123; print(&quot;Completed with no element&quot;) &#125;) .disposed(by: disposeBag) Driver它主要是为了简化 UI 层的代码.不会产生 error 事件,一定在 MainScheduler 监听（主线程监听）,共享状态变化. 1234567891011121314151617let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) &#125;results .map &#123; &quot;\\($0.count)&quot; &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in cell.textLabel?.text = &quot;\\(result)&quot; &#125; .disposed(by: disposeBag) 这段代码的主要目的是： 取出用户输入稳定后的内容 向服务器请求一组结果 将返回的结果绑定到两个 UI 元素上：tableView 和 显示结果数量的label 那么这里存在什么问题？ 如果 fetchAutoCompleteItems 的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求。 如果 fetchAutoCompleteItems 在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃。 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果。 一个更好的方案是这样的： 1234567891011121314151617181920let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) // 结果在主线程返回 .catchErrorJustReturn([]) // 错误被处理了，这样至少不会终止整个序列 &#125; .share(replay: 1) // HTTP 请求是被共享的results .map &#123; &quot;\\($0.count)&quot; &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in cell.textLabel?.text = &quot;\\(result)&quot; &#125; .disposed(by: disposeBag) 以下是使用 Driver 优化后的代码： 123456789101112131415161718let results = query.rx.text.asDriver() // 将普通序列转换为 Driver .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) // 仅仅提供发生错误时的备选返回值 &#125;results .map &#123; &quot;\\($0.count)&quot; &#125; .drive(resultCount.rx.text) // 这里改用 `drive` 而不是 `bindTo` .disposed(by: disposeBag) // 这样可以确保必备条件都已经满足了results .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in cell.textLabel?.text = &quot;\\(result)&quot; &#125; .disposed(by: disposeBag) drive 方法只能被 Driver 调用。这意味着，如果你发现代码所存在 drive，那么这个序列不会产生错误事件并且一定在主线程监听。这样你可以安全的绑定 UI 元素。 Observer - 观察者观察者需要去订阅(subscribe)被观察者(Observable)，才能收到Observable的事件通知消息.而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的. 123456789numbers .subscribe(onNext: &#123; num in print(&quot;取得 num 成功: \\(num)&quot;) &#125;, onError: &#123; error in print(&quot;取得 num 失败 Error: \\(error.localizedDescription)&quot;) &#125;, onCompleted: &#123; print(&quot;取得 num 任务成功完成&quot;) &#125;) .disposed(by: disposeBag) 特征观察者AnyObserverAnyObserver 可以用来描叙任意一种观察者。 1234567891011121314let observer: AnyObserver&lt;Data&gt; = AnyObserver &#123; (event) in switch event &#123; case .next(let data): print(&quot;Data Task Success with count: \\(data.count)&quot;) case .error(let error): print(&quot;Data Task Error: \\(error)&quot;) default: break &#125;&#125;URLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(observer) .disposed(by: disposeBag) Binder不会处理错误事件,确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler）.一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。 123456789101112let observer: AnyObserver&lt;Bool&gt; = AnyObserver &#123; [weak self] (event) in switch event &#123; case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break &#125;&#125;usernameValid .bind(to: observer) .disposed(by: disposeBag) 由于这个观察者是一个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执行.因此一个更好的方案就是使用 Binder： 1234567let observer: Binder&lt;Bool&gt; = Binder(usernameValidOutlet) &#123; (view, isHidden) in view.isHidden = isHidden&#125;usernameValid .bind(to: observer) .disposed(by: disposeBag) Binder 可以只处理 next 事件，并且保证响应 next 事件的代码一定会在给定 Scheduler 上执行，这里采用默认的 MainScheduler。 可被监听的序列也是观察者1234567// 作为可被监听的序列let observable = textField.rx.textobservable.subscribe(onNext: &#123; text in show(text: text) &#125;)// 作为观察者let observer = textField.rx.textlet text: Observable&lt;String?&gt; = ...text.bind(to: observer) 有许多 UI 控件都存在这种特性，例如：switch的开关状态，segmentedControl的选中索引号，datePicker的选中日期等等。 AsyncSubjectAsyncSubject 将在源 Observable 产生完成事件后，发出最后一个元素（仅仅只有最后一个元素），如果源 Observable 没有发出任何元素，只有一个完成事件。那 AsyncSubject 也只有一个完成事件。它会对随后的观察者发出最终元素。如果源 Observable 因为产生了一个 error 事件而中止， AsyncSubject 就不会发出任何元素，而是将这个 error 事件发送出来。123456789101112131415let disposeBag = DisposeBag()let subject = AsyncSubject&lt;String&gt;()subject .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🐶&quot;)subject.onNext(&quot;🐱&quot;)subject.onNext(&quot;🐹&quot;)subject.onCompleted()输出结果：Subscription: 1 Event: next(🐹)Subscription: 1 Event: completed PublishSubjectPublishSubject 将对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者。如果你希望观察者接收到所有的元素，你可以通过使用 Observable 的 create 方法来创建 Observable，或者使用 ReplaySubject。如果源 Observable 因为产生了一个 error 事件而中止， PublishSubject 就不会发出任何元素，而是将这个 error 事件发送出来。 123456789101112131415161718192021222324let disposeBag = DisposeBag()let subject = PublishSubject&lt;String&gt;()subject .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🐶&quot;)subject.onNext(&quot;🐱&quot;)subject .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🅰️&quot;)subject.onNext(&quot;🅱️&quot;)输出结果：Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️) ReplaySubjectReplaySubject 将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的 ReplaySubject，有的只会将最新的 n 个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把 ReplaySubject 当作观察者来使用，注意不要在多个线程调用 onNext, onError 或 onCompleted。这样会导致无序调用，将造成意想不到的结果。 12345678910111213141516171819202122232425let disposeBag = DisposeBag()let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)subject .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🐶&quot;)subject.onNext(&quot;🐱&quot;)subject .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🅰️&quot;)subject.onNext(&quot;🅱️&quot;)输出结果：Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 2 Event: next(🐱)Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️) BehaviorSubject当观察者对 BehaviorSubject 进行订阅时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果源 Observable 因为产生了一个 error 事件而中止， BehaviorSubject 就不会发出任何元素，而是将这个 error 事件发送出来。 12345678910111213141516171819202122232425262728293031323334353637383940let disposeBag = DisposeBag()let subject = BehaviorSubject(value: &quot;🔴&quot;)subject .subscribe &#123; print(&quot;Subscription: 1 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🐶&quot;)subject.onNext(&quot;🐱&quot;)subject .subscribe &#123; print(&quot;Subscription: 2 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🅰️&quot;)subject.onNext(&quot;🅱️&quot;)subject .subscribe &#123; print(&quot;Subscription: 3 Event:&quot;, $0) &#125; .disposed(by: disposeBag)subject.onNext(&quot;🍐&quot;)subject.onNext(&quot;🍊&quot;)输出结果：Subscription: 1 Event: next(🔴)Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 2 Event: next(🐱)Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️)Subscription: 3 Event: next(🅱️)Subscription: 1 Event: next(🍐)Subscription: 2 Event: next(🍐)Subscription: 3 Event: next(🍐)Subscription: 1 Event: next(🍊)Subscription: 2 Event: next(🍊)Subscription: 3 Event: next(🍊) Variable在 Swift 中我们经常会用 var 关键字来声明变量.RxSwift 提供的 Variable 实际上是 var 的 Rx 版本，你可以将它看作是 RxVar. 123456789101112131415161718192021222324252627282930313233//使用 var：// 在 ViewController 中var model: Model? = nil &#123; didSet &#123; updateUI(with: model) &#125;&#125;override func viewDidLoad() &#123; super.viewDidLoad() model = getModel()&#125;func updateUI(with model: Model?) &#123; ... &#125;func getModel() -&gt; Model &#123; ... &#125;//使用 Variable：// 在 ViewController 中let model: Variable&lt;Model?&gt; = Variable(nil)override func viewDidLoad() &#123; super.viewDidLoad() model.asObservable() .subscribe(onNext: &#123; [weak self] model in self?.updateUI(with: model) &#125;) .disposed(by: disposeBag) model.value = getModel()&#125;func updateUI(with model: Model?) &#123; ... &#125;func getModel() -&gt; Model &#123; ... &#125; 第一种使用 var 的方式十分常见，在 ViewController 中监听 Model 的变化，然后刷新页面。 第二种使用 Variable 则是 RxSwift 独有的。Variable 几乎提供了 var 的所有功能。另外，加上一条非常重要的特性，就是可以通过调用 asObservable() 方法转换成序列。然后你可以对这个序列应用操作符，来合成其他的序列。所以，如果我们声明的变量需要提供 Rx 支持，那就选用 Variable 这个类型。 Variable 封装了一个 BehaviorSubject，所以它会持有当前值，并且 Variable 会对新的观察者发送当前值。它不会产生 error 事件。Variable 在 deinit 时，会发出一个 completed 事件。 Disposable - 可被清除的资源通常来说，一个序列如果发出了 error 或者 completed 事件，那么所有内部资源都会被释放。如果你需要提前释放这些资源或取消订阅的话，那么你可以对返回的 可被清除的资源（Disposable） 调用 dispose 方法： 1234567891011121314var disposable: Disposable?override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.disposable = textField.rx.text.orEmpty .subscribe(onNext: &#123; text in print(text) &#125;)&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) self.disposable?.dispose()&#125; 调用 dispose 方法后，订阅将被取消，并且内部资源都会被释放。通常情况下，你是不需要手动调用 dispose 方法的，这里只是做个演示而已。我们推荐使用 清除包（DisposeBag） 或者 takeUntil 操作符 来管理订阅的生命周期。 清除包（DisposeBag）因为我们用的是 Swift ，所以我们更习惯于使用 ARC 来管理内存。那么我们能不能用 ARC 来管理订阅的生命周期了。答案是肯定了，你可以用 清除包（DisposeBag） 来实现这种订阅管理机制： 123456789101112131415var disposeBag = DisposeBag()override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) textField.rx.text.orEmpty .subscribe(onNext: &#123; text in print(text) &#125;) .disposed(by: self.disposeBag)&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) self.disposeBag = DisposeBag()&#125; takeUntil另外一种实现自动取消订阅的方法就是使用 takeUntil 操作符 12345678910111213141516171819202122232425override func viewDidLoad() &#123; super.viewDidLoad() ... _ = usernameValid .takeUntil(self.rx.deallocated) .bind(to: passwordOutlet.rx.isEnabled) _ = usernameValid .takeUntil(self.rx.deallocated) .bind(to: usernameValidOutlet.rx.isHidden) _ = passwordValid .takeUntil(self.rx.deallocated) .bind(to: passwordValidOutlet.rx.isHidden) _ = everythingValid .takeUntil(self.rx.deallocated) .bind(to: doSomethingOutlet.rx.isEnabled) _ = doSomethingOutlet.rx.tap .takeUntil(self.rx.deallocated) .subscribe(onNext: &#123; [weak self] in self?.showAlert() &#125;)&#125; 这将使得订阅一直持续到控制器的 dealloc 事件产生为止。 Schedulers - 调度器Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。 1234567891011121314151617// 后台取得数据，主线程处理结果DispatchQueue.global(qos: .userInitiated).async &#123; let data = try? Data(contentsOf: url) DispatchQueue.main.async &#123; self.data = data &#125;&#125;let rxData: Observable&lt;Data&gt; = ...rxData .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) .observeOn(MainScheduler.instance) .subscribe(onNext: &#123; [weak self] data in self?.data = data &#125;) .disposed(by: disposeBag) subscribeOn我们用 subscribeOn 来决定数据序列的构建函数在哪个 Scheduler 上运行。以上例子中，由于获取 Data 需要花很长的时间，所以用 subscribeOn 切换到 后台 Scheduler 来获取 Data。这样可以避免主线程被阻塞。 使用 observeOn我们用 observeOn 来决定在哪个 Scheduler 监听这个数据序列。以上例子中，通过使用 observeOn 方法切换到主线程来监听并且处理结果。 一个比较典型的例子就是，在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn 切到后台去发送请求并解析数据，最后用 observeOn 切换到主线程更新页面。 MainScheduler：MainScheduler 代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。 SerialDispatchQueueScheduler：SerialDispatchQueueScheduler 抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。 ConcurrentDispatchQueueScheduler：ConcurrentDispatchQueueScheduler 抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。 OperationQueueScheduler：OperationQueueScheduler 抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置 maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。 Error Handling - 错误处理一旦序列里面产出了一个 error 事件，整个序列将被终止。RxSwift 主要有两种错误处理机制 retry - 重试12345678910111213// 请求 JSON 失败时，立即重试，// 重试 3 次后仍然失败，就将错误抛出let rxJson: Observable&lt;JSON&gt; = ...rxJson .retry(3) .subscribe(onNext: &#123; json in print(&quot;取得 JSON 成功: \\(json)&quot;) &#125;, onError: &#123; error in print(&quot;取得 JSON 失败: \\(error)&quot;) &#125;) .disposed(by: disposeBag) 如果我们需要在发生错误时，经过一段延时后重试，那可以用retryWhen： 1234567891011121314151617// 请求 JSON 失败时，等待 5 秒后重试，// 重试 4 次后仍然失败，就将错误抛出let maxRetryCount = 4 // 最多重试 4 次let retryDelay: Double = 5 // 重试延时 5 秒rxJson .retryWhen &#123; (rxError: Observable&lt;Error&gt;) -&gt; Observable&lt;Int&gt; in return rxError.flatMapWithIndex &#123; (error, index) -&gt; Observable&lt;Int&gt; in guard index &lt; maxRetryCount else &#123; return Observable.error(error) &#125; return Observable&lt;Int&gt;.timer(retryDelay, scheduler: MainScheduler.instance) &#125; &#125; .subscribe(...) .disposed(by: disposeBag) 我们这里要实现的是，如果重试超过 4 次，就将错误抛出。如果错误在 4 次以内时，就等待 5 秒后重试，我们用 flatMapWithIndex 这个操作符，因为它可以给我们提供错误的索引数 index。然后用这个索引数判断是否超过最大重试数，如果超过了，就将错误抛出。如果没有超过，就等待 5 秒后重试。 catchError - 恢复catchError 可以在错误产生时，用一个备用元素或者一组备用元素将错误替换掉： 12345678910searchBar.rx.text.orEmpty ... .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in ... return searchGitHub(query) .catchErrorJustReturn([]) &#125; ... .bind(to: ...) .disposed(by: disposeBag) Result1234567891011121314151617// 当用户点击更新按钮时，// 就立即取出修改后的用户信息。// 然后发起网络请求，进行更新操作，// 一旦操作失败就提示用户失败原因updateUserInfoButton.rx.tap .withLatestFrom(rxUserInfo) .flatMapLatest &#123; userInfo -&gt; Observable&lt;Void&gt; in return update(userInfo) &#125; .observeOn(MainScheduler.instance) .subscribe(onNext: &#123; print(&quot;用户信息更新成功&quot;) &#125;, onError: &#123; error in print(&quot;用户信息更新失败： \\(error.localizedDescription)&quot;) &#125;) .disposed(by: disposeBag) 这样实现是非常直接的。但是一旦网络请求操作失败了，序列就会终止。整个订阅将被取消。如果用户再次点击更新按钮，就无法再次发起网络请求进行更新操作了。 为了解决这个问题，我们需要选择合适的方案来进行错误处理。例如使用枚举 Result： 1234567891011121314151617181920212223// 自定义一个枚举类型 Resultpublic enum Result&lt;T&gt; &#123; case success(T) case failure(Swift.Error)&#125;updateUserInfoButton.rx.tap .withLatestFrom(rxUserInfo) .flatMapLatest &#123; userInfo -&gt; Observable&lt;Result&lt;Void&gt;&gt; in return update(userInfo) .map(Result.success) // 转换成 Result .catchError &#123; error in Observable.just(Result.failure(error)) &#125; &#125; .observeOn(MainScheduler.instance) .subscribe(onNext: &#123; result in switch result &#123; // 处理 Result case .success: print(&quot;用户信息更新成功&quot;) case .failure(let error): print(&quot;用户信息更新失败： \\(error.localizedDescription)&quot;) &#125; &#125;) .disposed(by: disposeBag) 这样我们的错误事件被包装成了 Result.failure(Error) 元素，就不会终止整个序列。就算网络请求失败，整个订阅依然存在。如果用户再次点击更新按钮，也是能够发起网络请求进行更新操作的。","path":"2017/10/20/RxSwift核心概念/","date":"10-20","excerpt":""},{"title":"路由协议","text":"项目组件化的好处随着工程的代码的增加，业务逻辑也越来越复杂以及开发人员的增多.致使项目各个模块之间耦合性很强.组件化的目的就是重用高度抽象化代码单元. 项目组件化的实施 使用Cocoapods的模块化功能, 将一些通用的类, 工具类, 封装成私有的Pod(参考这里). 这样一来, 就把基础代码从项目中抽离出来, 其他的项目要想使用, 只需依赖我们的私有Pod就可以了. 通过路由协议, 相当于我们通过一个中间层来转发我们组件与组件之间的通信, 这样就实现了组件之间的解耦, 而组件内部又是完整的业务逻辑, 属于高内聚, 低耦合. 路由协议的好处 外部跳转到App内部一个很深层次的一个界面. App之间的相互跳转. 解除App组件之间和App页面之间的耦合性. 统一iOS和Android两端的页面跳转逻辑, 统一三端的请求资源的方式. iOS和Android两边只要共用一套动态下发配置文件来配置App的跳转逻辑. 在App任何界面都可以调用任意一个界面或者任意一个组件. 参考资料 蘑菇街App的组件化之路 蘑菇街App的组件化之路.续 iOS应用架构谈 组件化方案 iOS组件化方案探讨 iOS 组件化 —— 路由设计思路分析","path":"2017/10/14/iOS组件化/","date":"10-14","excerpt":""},{"title":"多线程使用","text":"死锁1234567dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; NSLog(@&quot;任务1...%@&quot;,[NSThread currentThread]);&#125;); NSLog(@&quot;任务2...%@&quot;,[NSThread currentThread]); 以上queue为主队列所以dispatch_sync默认在主线程执行，dispatch_sync又是同步所以会阻塞当前线程（主线程），而主队列又是串行队列，所以任务只能按照顺序执行.这就造成了dispatch_sync阻塞将任务1加入队列放到任务2后面，等待任务2执行完毕才能执行，而任务2又在等dispatch_sync中的任务1执行完毕才能执行。最后形成任务互相等待的结局，造成了死锁. GCD向串行队列中添加异步任务123456789101112131415161718//创建串行队列, 第一个参数为串行队列的名称, 第二个参数为队列的属性, NULL或者DISPATCH_QUEUE_SERIAL表示是串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.levinluo.thread&quot;, NULL); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]); sleep(5); &#125;); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]); &#125;); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]); &#125;); 该过程一共分为两步, 第一步创建串行队列, 第二步向串行队列中添加异步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 但是由于我们是在串行队列中添加的任务, 所有任务在同一个线程中执行, 所有的异步任务会按照顺序前一个执行完毕再执行后一个. GCD向串行队列中添加同步任务123456789101112131415161718//创建串行队列, 第一个参数为串行队列的名称, 第二个参数为队列的属性, NULL或者DISPATCH_QUEUE_SERIAL表示是串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.levinluo.thread&quot;, NULL); //向队列中添加同步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]); sleep(5); &#125;); //向队列中添加同步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]); &#125;); //向队列中添加同步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]); &#125;); 该过程一共分为两步, 第一步创建串行队列, 第二步向串行队列中添加同步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 但是由于我们是在串行队列中添加的任务, 所有任务在同一个线程中执行, 所有的异步任务会按照顺序前一个执行完毕再执行后一个.注意，如果这里是主队列的话就会造成死锁. GCD向并行队列中添加异步任务123456789101112131415161718//获取系统提供的全局队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]); sleep(5); &#125;); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]); &#125;); //向队列中添加异步任务 dispatch_async(queue, ^&#123; NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]); &#125;); 该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 但是每个任务何时执行完我们却并不知道. 但是系统会新开线程来执行异步任务, 三个异步任务会分别在三个线程中执行, 各个任务的执行顺序无法确定. GCD向并行队列添加同步任务1234567891011121314151617dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //向队列中添加异步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]); sleep(5); &#125;); //向队列中添加异步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]); &#125;); //向队列中添加异步任务 dispatch_sync(queue, ^&#123; NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]); &#125;); 该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加同步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 虽然是并行队列, 单由于添加的是同步任务, 不会新开线程, 全都在当前线程中执行, 所以三个任务会顺序执行, 并行队列失去了并行的能力. Dispatch Group分组模式 dispatch_group_notify. 可以异步执行多个耗时操作. 等耗时操作都执行完毕之后会回到主线程执行操作, 主要用于监听任务是否完成. 主要有两种用法: 第一种用法是通过dispatch_group_async, 首先创建一个全局并行队列和一个group队列组, 再次创建异步group任务加入到前面创建的group队列中去. 当所有异步任务完成后, 会通过dispatch_group_notify回到主线程. 123456789101112131415161718192021222324//获取全局队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //创建一个队列组 dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;--- 1 开始--- %@&quot;, [NSThread currentThread]); //延时5秒 模仿堵塞子线程 [NSThread sleepForTimeInterval:5]; NSLog(@&quot;--- 1 --- 完成 %@&quot;, [NSThread currentThread]); &#125;); dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;--- 2 开始--- %@&quot;, [NSThread currentThread]); //延时5秒 模仿堵塞子线程 [NSThread sleepForTimeInterval:5]; NSLog(@&quot;--- 2 --- 完成 %@&quot;, [NSThread currentThread]); &#125;); //在这个队列组里面，会等group中的全部代码执行完毕再去执行其它的操作 dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步操作都执行完毕后，回到主线程... NSLog(@&quot;全部完成&quot;); &#125;); 第二种用法是通过信号量dispatch_group_enter 和 dispatch_group_leave. 创建一个并行线程和多个异步任务, 将异步任务添加到并行线程中区. 通过dispatch_group_enter来告知group一个异步任务开始, 未执行完毕任务数加1. 在异步线程任务执行完毕时, 通过dispatch_group_leave告知group, 一个任务结束, 未执行完毕任务数减1. 当未执行完毕任务数为0的时候, 这时group才认为组内任务都执行完毕了(这个和GCD的信号量的机制有些相似), 这时候才会回调dispatch_group_notify中的block. 此处需要注意, dispatch_group_enter和dispatch_group_leave的数量一定要一致. 1234567891011121314151617181920dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_enter(group); dispatch_async(queue, ^&#123; sleep(2); //这里线程睡眠1秒钟，模拟异步请求 NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; sleep(2); //这里线程睡眠1秒钟，模拟异步请求 NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;group finished&quot;); &#125;); GCD延时操作(dispatch_after)使用很简单, 两个核心的对象dispatch_time_t和dispatch_after. 大家都经常使用, 不用多说. 下面的代码和在3妙手用dispatch_async函数追加block到主线程的操作是相同的 123456double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); //第一个参数代表时间, 第二各参数代表要在哪个线程执行接下来的任务, 第三个参数就是任务block dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;); GCD单例12345678910111213@interface Tool : NSObject+ (instancetype)sharedTool;@end@implementation Toolstatic id _instance;+ (instancetype)sharedTool &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [[Tool alloc] init]; &#125;); return _instance;&#125;@end GCD 线程间的通讯1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; //在这里执行耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; //在主线程使用上面操作的结果 &#125;); &#125;); GCD重复执行同一个任务12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_apply(10, queue, ^(size_t index) &#123; //并行处理10次任务 NSLog(@&quot;%zu&quot;, index); &#125;); 由于dispatch_apply函数与dispatch_sync函数相同, 会等待任务执行结束, 所以推荐在dispatch_async函数中异步执行. 12345678910111213141516dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //在全局并行队列中异步执行 dispatch_async(queue, ^&#123; //等待函数中操作全部执行完毕 dispatch_apply(10, queue, ^(size_t index) &#123; //并行处理10次任务 sleep(2); NSLog(@&quot;%zu&quot;, index); &#125;); //dispatch_apply中的处理全部结束, 在主线程异步执行 dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Done&quot;); &#125;); &#125;); GCD设置优先级1234dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL); dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //把第一个参数的执行优先级设置的和第二个参数的优先级一致. dispatch_set_target_queue(queue, queue1); GCD栅栏假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入dispatch_barrier_async任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行dispatch_barrier_async任务, 然后再无序执行后两次任务. 注意此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行 12345678910111213141516171819202122//此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行 dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@&quot;1&quot;); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;3&quot;); &#125;); dispatch_barrier_async(queue, ^&#123; sleep(3); NSLog(@&quot;插入执行&quot;); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;4&quot;); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;5&quot;); &#125;); GCD信号量信号量来控制任务的执行. dispatch_semaphore_t类似于单个队列的最大并发数控制机制, 提高并行效率的同时, 也可以防止太多线程的开辟对系统造成太大的负担.1234567891011121314151617181920212223242526dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); NSMutableArray *array = [[NSMutableArray alloc]init]; for (NSInteger i = 0; i &lt; 100000; i++) &#123; dispatch_async(queue, ^&#123; /* 此时semaphore信号量的值如果 &gt;= 1时：对semaphore计数进行减1,然后dispatch_semaphore_wait 函数返回。该函数所处线程就继续执行下面的语句。 此时semaphore信号量的值如果=0：那么就阻塞该函数所处的线程,阻塞时长为timeout指定的时间，如果阻塞时间内semaphore的值被dispatch_semaphore_signal函数加1了，该函数所处线程获得了信号量被唤醒。然后对semaphore计数进行减1并返回，继续向下执行。 如果阻塞时间内没有获取到信号量唤醒线程或者信号量的值一直为0，那么就要等到指定的阻塞时间后，该函数所处线程才继续向下执行。 执行到这里semaphore的值总是1 */ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /* 因为dispatch_semaphore_create创建的semaphore的初始值为1，执行完上面的 dispatch_semaphore_wait函数之后，semaphore计数值减1会变为0，所以可访问array对象的线程只有1个，因此可安全地对array进行操作。 */ [array addObject:[NSNumber numberWithInteger:i]]; /* 对array操作之后，通过dispatch_semaphore_signal将semaphore的计数值加1，此时semaphore的值由变成了1，所处 */ dispatch_semaphore_signal(semaphore); &#125;); &#125; GCD定时器12345678910111213141516171819202122NSLog(@&quot;%@&quot;, [NSThread currentThread]); //指定DISPATCH_SOURCE_TYPE_TIMER类型, 作成Dispatch Source //在定时器经过指定时间, 把任务追加到main queue dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue()); //定时器的相关设置, 将定时器设置为5s后, 不指定为重复, 允许延迟1s dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC); //指定定时器指定时间内执行的处理 dispatch_source_set_event_handler(timer, ^&#123; NSLog(@&quot;wake up&quot;); dispatch_source_cancel(timer); &#125;); //取消定时器时的处理 dispatch_source_set_cancel_handler(timer, ^&#123; NSLog(@&quot;canceled&quot;); &#125;); //定时器启动 dispatch_resume(timer); NSOperation的优先级NSOperationQueue中NSOperation对象的执行方式是按照FIFO的原则顺序执行, 但是如果我们设置了任务的优先级, 那么系统就会给优先级高的优先分配资源. 优先级一共有这几种, 从高到低依次排列. 1234567typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;; 示例代码如下, 三个任务被添加到队列中去, 这三个任务分别在三个线程, 互不干扰, 类似于GCD的异步并行模式, 如果我们设置invocationOper.queuePriority = NSOperationQueuePriorityVeryLow理论上, invocationOper任务会在最后执行, 但是我们发现并没有, 那是因为我们没有设置最大并发数的原因, 我猜测系统可能是做了某些限制, 虽然是新开了线程, 但是由于最大并发数小于等于1实际还是按照FIFO顺序执行, 所以注意一定要设置最大并发数 123456789101112131415161718//把注释打开就可以看到想要的效果- (void)NSOperationQueueRun &#123; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //queue.maxConcurrentOperationCount = 3; NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; //invocationOper.queuePriority = NSOperationQueuePriorityVeryLow; [queue addOperation:invocationOper]; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]); &#125;]; [queue addOperation:blockOper]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]); &#125;];&#125;- (void)invocationOperSel &#123; NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);&#125; NSOperation的依赖关系首先我们创建一个队列, 分别创建要执行的任务, 在把要执行的任务添加到队列中去之前, 通过addDependency来建立任务间的依赖关系. 如果我们没有设置依赖的话, 如果设置的并发数大于1, 那么blockOper_1和`blockOper_2的执行顺序是随机的. 可是当我们执行[blockOper_1 addDependency:blockOper_2]时, 就给两个任务添加了依赖关系, blockOper_1永远只会在blockOper_2后执行. 即使我们给blockOper_1设置了最高的优先级, 因为依赖的优先级要高于queuePriority. 12345678910111213141516- (void)NSOperationQueueRun2 &#123; NSOperationQueue *queue = [[NSOperationQueue alloc] init];// queue.maxConcurrentOperationCount = 2; NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;blockOper_1_%@_%@&quot;,@(1),[NSThread currentThread]); &#125;]; NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;blockOper_2_%@_%@&quot;,@(2),[NSThread currentThread]); &#125;]; // blockOper_1.queuePriority = NSOperationQueuePriorityVeryHigh; [blockOper_1 addDependency:blockOper_2]; [queue addOperation:blockOper_1]; [queue addOperation:blockOper_2];&#125;","path":"2017/09/26/多线程使用/","date":"09-26","excerpt":""},{"title":"多线程","text":"概念进程和线程进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体，是CPU调度和分派（资源分配）的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他线程共享进程所拥有的全部资源. 并发和并行并发指能够让多个任务在逻辑上交织执行的程序设计, 但并发事件之间不一定要同一时刻发生. 并行指的是程序运行时的状态是物理上同时执行, 是指同时发生的两个并发事件, 具有并发的含义, 而并发则不一定并行.并发是一种现象, 面对这一现象, 我们首先创建多个线程. 真正加快程序运行速度的, 是并行技术. 也就是让多个CPU同时工作. 而多线程, 是为了让多个CPU同时工作成为可能. 并发设计让并发执行成为可能, 而并行是并发执行的一种模式. 并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头. 一个人同时吃三个馒头但是同一时间只能啃一个馒头, 三个人同时吃三个馒头, 三个馒头同一时间都会被啃. 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况. 假设每个核心有两个线程, 那么每个CPU中两个线程会交替并发, 两个CPU之间的操作会并行运算. 就CPU1而言虽然实现了并发但是同一时间只有一个任务在进行, CPU只是快速的在任务之间切换, CPU1和CPU2整体来看是并行元算, 同一时间是有多个任务在进行. 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题, 其本身运行效率并没有提高. 多CPU的并行运算才真正解决了运行效率问题, 这也正是并发和并行的区别. 同步和异步同步在发出一个同步调用时, 在没有得到结果之前, 该调用就不返回. 多个任务情况下, 一个任务A执行结束, 才可以执行另一个任务B. 只存在一个线程. 异步在发出一个异步调用后, 调用者不会立刻得到结果, 该调用就返回了. 只要是同步执行的任务，都会在当前线程执行，不会另开线程.只要是异步执行的任务，都会另开线程，在别的线程执行. iOS多线程方案pthreadPOSIX线程(POSIX threads), 简称Pthreads, 是线程的POSIX标准. 该标准定义了创建和操纵线程的一整套API, 在类Unix操作系统(Unix、Linux、Mac OSX等)中, 都使用Pthreads作为操作系统的线程. 那也就意味着可以跨平台使用. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;pthread.h&gt;//属性pthread_t：线程指针pthread_attr_t：线程属性pthread_mutex_t：互斥对象pthread_mutexattr_t：互斥属性对象pthread_cond_t：条件变量pthread_condattr_t：条件属性对象pthread_key_t：线程数据键pthread_rwlock_t：读写锁//方法pthread_create()：创建一个线程pthread_exit()：终止当前线程pthread_cancel()：中断另外一个线程的运行pthread_join()：阻塞当前的线程, 直到另外一个线程运行结束pthread_attr_init()：初始化线程的属性pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）pthread_attr_getdetachstate()：获取脱离状态的属性pthread_attr_destroy()：删除线程的属性pthread_kill()：向线程发送一个信号pthread_equal(): 对两个线程的线程标识号进行比较pthread_detach(): 分离线程pthread_self(): 查询线程自身线程标识号/*创建线程 int pthread_create(pthread_t _Nullable * _Nonnull __restrict, //指向新建线程标识符的指针 const pthread_attr_t * _Nullable __restrict, //设置线程属性. 默认值NULL. void * _Nullable (* _Nonnull)(void * _Nullable), //该线程运行函数的地址 void * _Nullable __restrict); //运行函数所需的参数 *返回值： *若线程创建成功, 则返回0 *若线程创建失败, 则返回出错编号 */pthread_t thread = NULL;NSString *params = @&quot;Hello World&quot;;int result = pthread_create(&amp;thread, NULL, threadTask, (__bridge void *)(params));result == 0 ? NSLog(@&quot;creat thread success&quot;) : NSLog(@&quot;creat thread failure&quot;);//设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源pthread_detach(thread);void *threadTask(void *params) &#123; NSLog(@&quot;%@ - %@&quot;, [NSThread currentThread], (__bridge NSString *)(params)); return NULL;&#125; NSThread1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@interface NSThread : NSObject//当前线程@property (class, readonly, strong) NSThread *currentThread;//使用类方法创建线程执行任务+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;//判断当前是否为多线程+ (BOOL)isMultiThreaded;//指定线程的线程参数, 例如设置当前线程的断言处理器. @property (readonly, retain) NSMutableDictionary *threadDictionary;//当前线程暂停到某个时间+ (void)sleepUntilDate:(NSDate *)date;//当前线程暂停一段时间+ (void)sleepForTimeInterval:(NSTimeInterval)ti;//退出当前线程+ (void)exit;//当前线程优先级+ (double)threadPriority;//设置当前线程优先级+ (BOOL)setThreadPriority:(double)p;//指定线程对象优先级 0.0～1.0, 默认值为0.5@property double threadPriority NS_AVAILABLE(10_6, 4_0);//服务质量@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//线程名称@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);//栈区大小@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);//是否为主线程@property (class, readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);//获取主线程@property (class, readonly, strong) NSThread *mainThread NS_AVAILABLE(10_5, 2_0);//初始化- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;//实例方法初始化, 需要再调用start方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));//线程状态, 正在执行@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);//线程状态, 正在完成@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);//线程状态, 已经取消@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);//取消, 仅仅改变线程状态, 并不能像exist一样真正的终止线程- (void)cancel NS_AVAILABLE(10_5, 2_0);//开始- (void)start NS_AVAILABLE(10_5, 2_0);//线程需要执行的代码, 一般写子类的时候会用到- (void)main NS_AVAILABLE(10_5, 2_0);@end 还有一个NSObject的分类 12345678@interface NSObject (NSThreadPerformAdditions)//隐式的创建并启动线程, 并在指定的线程（主线程或子线程）上执行方法. - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);@end 常见的用法有以下几种: 123456789101112- (void) startThread &#123; //创建并且手动启动 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; //类方法创建并且自动启动 [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; //通过NSObject的方法自动启动 [self performSelectorInBackground:@selector(run) withObject:nil];&#125; - (void)run &#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125; GCDGrand Central Dispatch, 它是苹果为多核的并行运算提出的解决方案, 会自动合理地利用更多的CPU内核(比如双核、四核), 最重要的是它会自动管理线程的生命周期(创建线程、调度任务、销毁线程), 完全不需要我们管理, 我们只需要告诉干什么就行. 同时它使用的也是C语言. 任务要执行的操作或方法函数. 在GCD中指的就是block块, 在NSThread中指的是performSelector:中的方法. 加入任务时有两种形式: 同步任务(dispatch_sync)和异步任务(dispatch_async). 同步任务: 不会开启新的线程, 会阻塞当前线程. 完成需要做的任务后才会返回, 进行下一任务. 创建方式为: 12//把右边的参数(任务)提交给左边的参数(队列)进行执行dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 异步任务: 不会等待任务完成才返回, 会立即返回. 异步是多线程的代名词, 因为必定会开启新的线程, 线程的申请是由异步负责, 起到开分支的作用. 创建方式为: 12//把右边的参数(任务)提交给左边的参数(队列)进行执行dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 队列存放任务的集合, 我们要做的就是将任务添加到队列然后执行, GCD会自动将队列中的任务按先进先出的方式取出. 队列主要有的有串行队列(Serial Dispatch Queue), 并行队列(Concurrent Dispatch Queue), 全局队列(Global Queue)和主队列(Main Queue). 串行队列: 任务依次执行, 同一时间队列中只有一个任务在执行, 每个任务只有在前一个任务执行完成后才能开始执行 1234//创建一个名为queue的串行队列//第一个参数为队列名称//第二个参数为队列类型, DISPATCH_QUEUE_SERIAL和NULL表示串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.levinluo.SerialQueue&quot;, DISPATCH_QUEUE_SERIAL); 并行队列: 任务并发执行, 唯一能保证的是, 这些任务会按照被添加的顺序开始执行. 但是任务可以以任何顺序完成, 你不知道在执行下一个任务是从什么时候开始, 或者说任意时刻有多个Block(任务)运行, 这个完全是取决于GCD. 1234//创建一个名为queue的并行队列//第一个参数为队列名称//第二个参数为队列类型, DISPATCH_QUEUE_CONCURRENT表示并行队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.levinluo.ConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT); 全局队列: GCD默认提供的全局的并发队列, 供整个应用使用 123456789//获取系统全局队列, 并赋值给队列queue//第一个参数表示优先级, 这里是新老优先级的对照Map* - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED//高* - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT//默认* - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY//低* - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND//后台 //第二个参数是预留参数, 传0就好dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 主队列: 主队列是GCD自带的一种特殊的串行队列, 放在主队列中的任务, 都会放到主线程中执行 12//获取系统主队列, 并赋值给队列queue dispatch_queue_t queue = dispatch_get_main_queue(); 不管是串行队列(SerialQueue)还是并行队列(ConcurrencyQueue), 都是FIFO队列. 也就意味着, 任务一定是一个一个地, 按照先进先出的顺序来执行. NSOperation &amp; NSOperationQueueNSOperation 是苹果公司对GCD的封装, NSOperation和NSOperationQueue分别对应GCD的任务和队列.首先将要执行的任务封装到一个NSOperation对象中. 然后将此任务添加到一个NSOperationQueue对象中. NSOperation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@interface NSOperation : NSObject &#123;@private id _private; int32_t _private1;#if __LP64__ int32_t _private1b;#endif&#125; - (void)start;//启动任务 默认在当前线程执行- (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。 @property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读- (void)cancel;//取消任务 @property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读@property (readonly, getter=isFinished) BOOL finished;//执行结束，只读@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &apos;asynchronous&apos; below@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读@property (readonly, getter=isReady) BOOL ready;//准备执行 - (void)addDependency:(NSOperation *)op;//添加依赖- (void)removeDependency:(NSOperation *)op;//移除依赖 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读 typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;;//系统提供的优先级关系枚举 @property NSOperationQueuePriority queuePriority;//执行优先级 @property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调 - (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。 @property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。 @property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。 @property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称 @end 由于NSOperation是一个抽象基类, 不能直接使用, 在这里我们一般使用NSOperation的两个子类NSInvocationOperation和NSBlockOperation, 或者NSOperation的自定义子类: NSInvocationOperation：基于应用的一个target对象和selector来创建operation object. 如果你已经有现有的方法来执行需要的任务, 就可以使用这个类. 使用方式大致如下: 1234567- (void)NSInvocationOperationRun &#123; NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; [invocationOper start];&#125;- (void)invocationOperSel &#123; NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);&#125; NSBlockOperation用来并发地执行一个或多个block对象. operation object使用组的语义来执行多个block对象，所有相关的 block 都执行完成之后, operation object才算完成. 使用方法如下: 12345678910111213//系统提供的API@interface NSBlockOperation : NSOperation &#123;@privateid _private2;void *_reserved2;&#125; + (instancetype)blockOperationWithBlock:(void (^)(void))block;//在当前线程执行 - (void)addExecutionBlock:(void (^)(void))block;//新开线程执行@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks; @end 使用NSBlockOperation类方法创建任务, 从打印结果可以看出来该任务是在主线程执行的 123456- (void)NSBlockOperationRun &#123;NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_%@_%@&quot;, [NSOperationQueue currentQueue], [NSThread currentThread]);&#125;];[blockOper start];&#125; 使用NBlockOperation的实例方法创建任务, 从打印结果可以看出来, 第一个任务是在主线程执行, 其他任务均是新开的线程, 所有的任务是以异步并发的形式执行. 123456789101112131415- (void)NSBlockOperationRun &#123;NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_1_%@&quot;, [NSThread currentThread]);&#125;];[blockOper addExecutionBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_2_%@&quot;, [NSThread currentThread]);&#125;];[blockOper addExecutionBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_3_%@&quot;, [NSThread currentThread]);&#125;];[blockOper addExecutionBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_4_%@&quot;, [NSThread currentThread]);&#125;];[blockOper start];&#125; NSOperation的自定义子类. 在子类中重写父类的-(void)main函数, 在里面实现主要逻辑. NSBlockOperation, NSBlockOperationRun或者NSOperation的自定义子类创建的operation object都可以使用NSOperation的所有属性, 意味着他们具有以下主要特性: 多个任务之间可以使用有依赖关系 可以获得Operation object任务执行完成之后的回调 支持应用使用 KVO 通知来监控 operation 的执行状态 可以通过operation优先级, 从而影响相对的执行顺序 可以终止正在执行的任务 NSOperationQueueNSOperationQueue类似于GCD中的队列, 只需要吧任务加入到NSOperationQueue中, 就会自动运行, 由系统通过最大并发数来控制是并行还是串行, 官方提供的API如下: 1234567891011121314151617181920212223242526272829303132333435static const NSInteger NSOperationQueueDefaultMaxConcurrentOperationCount = -1; NS_CLASS_AVAILABLE(10_5, 2_0)@interface NSOperationQueue : NSObject &#123;@private id _private; void *_reserved;&#125; - (void)addOperation:(NSOperation *)op;//向队列中添加任务- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一组任务 - (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一个block形式的任务 @property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;//队列中所有任务的数组@property (readonly) NSUInteger operationCount API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//队列中所有任务数 @property NSInteger maxConcurrentOperationCount;//最大并发数 @property (getter=isSuspended) BOOL suspended;//暂停 @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//名称 @property NSQualityOfService qualityOfService API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));//服务质量, 系统会为权重高的服务分配更多的资源 @property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); - (void)cancelAllOperations;//取消队列中所有的任务 - (void)waitUntilAllOperationsAreFinished;//阻塞当前线程, 等到队列中的全部任务全部执行完毕 @property (class, readonly, strong, nullable) NSOperationQueue *currentQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取当前队列@property (class, readonly, strong) NSOperationQueue *mainQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取主队列 @end 1234567891011121314151617//以三种方式为队列添加了三个任务, - (void)NSOperationQueueRun &#123; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; [queue addOperation:invocationOper]; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]); &#125;]; [queue addOperation:blockOper]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]); &#125;];&#125; - (void)invocationOperSel &#123; NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);&#125; 一般情况下, NSOperationQueue会按照任务添加的顺序来执行任务, 但是我们可以通过使用优先级和依赖关系来改变执行顺序.","path":"2017/09/15/多线程/","date":"09-15","excerpt":""},{"title":"runloop实践","text":"常驻线程需要创建一个在后台一直存在的程序, 来做一些需要频繁处理的任务. 比如检测网络状态等. 默认情况一个线程创建出来, 运行完要做的事情, 线程就会消亡. 而程序启动的时候, 就创建的主线程已经加入到runloop, 所以主线程不会消亡. AFN里面就有一条通过添加NSPort来实现常驻的线程, 常见的有两种方式: 添加NSPort 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [self.thread start];&#125;- (void)run &#123; NSLog(@&quot;----------run----%@&quot;, [NSThread currentThread]); @autoreleasepool&#123; /*如果不加这句，会发现runloop创建出来就挂了，因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。 下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉*/ [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; // 方法1 [[NSRunLoop currentRunLoop] run]; &#125; // 方法2 [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; // 方法3 [[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]]; NSLog(@&quot;---------&quot;);&#125;- (void)test &#123; NSLog(@&quot;----------test----%@&quot;, [NSThread currentThread]);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125; 添加NSTimer 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [self.thread start];&#125;- (void)run &#123; [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run];&#125; 如果没有实现添加NSPort或者NSTimer, 会发现执行完run方法, 线程就会消亡, 后续再执行touchbegan方法无效. 我们必须保证线程不消亡, 才可以在后台接受时间处理. RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source, 所以在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了. 通常情况下, 调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内; 但此处添加 port 只是为了让 RunLoop 不至于退出, 并没有用于实际的发送消息. 可以发现执行完了run方法, 这个时候再点击屏幕, 可以不断执行test方法, 因为线程self.thread一直常驻后台, 等待事件加入其中, 然后执行. 参考链接：避免使用 GCD Global队列创建Runloop常驻线程 滚动scrollView导致定时器失效如果在界面上有一个UIscrollview控件(tableview, collectionview等), 如果此时还有一个定时器在执行一个事件, 你会发现当你滚动scrollview的时候, 定时器会失效. 原因是当滚动UIscrollview的时候, runloop会进入UITrackingRunLoopMode 模式, 而定时器运行在defaultMode下面, 系统一次只能处理一种模式的runloop, 所以导致defaultMode下的定时器失效. 解决方案有两种: 1.把定时器的runloop的model改为NSRunLoopCommonModes 模式, 这个模式是一种占位mode, 并不是真正可以运行的mode, 它是用来标记一个mode的. 默认情况下default和tracking这两种mode 都会被标记上NSRunLoopCommonModes 标签 改变定时器的mode为commonmodel, 可以让定时器运行在defaultMode和trackingModel两种模式下, 不会出现滚动scrollview导致定时器失效的故障.1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 使用GCD创建定时器1234567891011121314151617// 获得队列dispatch_queue_t queue = dispatch_get_main_queue();// 创建一个定时器(dispatch_source_t本质还是个OC对象)self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）// 比当前时间晚1秒开始执行dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));//每隔一秒执行一次uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);dispatch_source_set_timer(self.timer, start, interval, 0);// 设置回调dispatch_source_set_event_handler(self.timer, ^&#123; NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);&#125;);// 启动定时器dispatch_resume(self.timer); 图片下载由于图片渲染到屏幕需要消耗较多资源, 为了提高用户体验, 当用户滚动UIscrollview的时候, 只在后台下载图片, 但是不显示图片, 当用户停下来的时候才显示图片. 核心代码如下: 1[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 这是因为限定了方法setImage只能在NSDefaultRunLoopMode 模式下使用. 而滚动UIscrollview的时候, 程序运行在tracking模式下面, 所以方法setImage不会执行.","path":"2017/08/11/runloop实践/","date":"08-11","excerpt":""},{"title":"runloop","text":"RunLoop的概念RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供一个入口函数执行Event Loop的逻辑.线程执行了这个函数后，就会一直处于这个函数内部“接收消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束（比如传入quit消息）. runloop在iOS开发中的作用是： runloop保持主线程不会被销毁，能保证程序的持续运行.（程序一启动就会开启一个主线程，主线程中的runloop是自动创建并运行的） 处理App中的各种事件(如: touches 触摸事件, NSTimer 定时器事件） 节省CPU资源, 提高程序性能(有事情就做事情, 没事情就休息(其资源释放)). 负责渲染屏幕上的所有UI 获取线程中的runloop苹果不允许直接创建 RunLoop, 它只提供了两个自动获取的函数. Foundation： [NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象 [NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation： CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象 CFRunLoopGetMain(); // 获得主线程的RunLoop对象 iOS提供了两个这样的对象: NSRunLoop 和 CFRunLoopRef. CFRunLoopRef 是在 CoreFoundation 框架内的, 它提供了纯 C 函数的 API, 所有这些 API 都是线程安全的.NSRunLoop 是基于 CFRunLoopRef 的封装, 提供了面向对象的 API, 但是这些 API 不是线程安全的. CFDictionarySetValue(loopsDic, thread, loop)线程与RunLoop之间是一一对应的关系，保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop. RunLoop ModeCFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRe从上图中可以看出一个RunLoop对象中可以包含多个Mode,每个Mode又包含若干个 Source/Timer/Observer.但是每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode.如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响. 如果一个 mode 中一个 item 都没有, 则 RunLoop 会直接退出, 不进入循环. CFRunLoopSourceRefCFRunLoopSourceRef是事件源(输入源), 例如外部的触摸, 点击事件和系统内部进程间的通信等 source0:非基于Port的,用于用户主动触发的事件source1:基于Port的，通过内核和其他线程相互发送消息 CFRunLoopTimerRef是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。它受RunLoop的Mode影响, GCD的定时器不受RunLoop的Mode影响. CFRunLoopObserverRef每个 Observer 都包含了一个回调(函数指针)当 RunLoop 的状态发生变化时, 观察者就能通过回调接受到这个变化. 可以观测的时间点有以下几个: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop （1） kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer （2） kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source （4） kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 （32） kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 (64) kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop (128) kCFRunLoopAllActivities = 0x0FFFFFFU, // 包含上面所有状态&#125;; CFRunLoopModeRef系统默认注册了5个Mode: NSDefaultRunLoopMode: App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态. UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到. NSRunLoopCommonModes: 这是一个占位用的Mode, 不是一种真正的Mode. 这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.应用场景举例: 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作. 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到commonMode 中。那么所有被标记为commonMode的mode（defaultMode和TrackingMode）都会执行该timer。这样你在滑动界面的时候也能够调用timer 运行RunLoop具体的流程 参考资料：深入理解RunLoop","path":"2017/08/07/runloop/","date":"08-07","excerpt":""},{"title":"runtime实践","text":"例题分析[self class]与[super class]1234567891011@implementation Son : Father- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125;return self;&#125;@end 运行结果： 122017-07-23 12:27:36.776910+0800 Runtime[2173:159137] Son2017-07-23 12:27:36.777059+0800 Runtime[2173:159137] Son 当调用[self class]时, 先调用的是 objc_msgSend 函数, 第一个参数是Son这个类的实例, 然后去示例的ISA(Son类)中找 - (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 而 - (Class)class 的实现就是返回self的类别, 故上述输出结果为 Son. 当调用[supe class]时, 先调用的是class_getSuperclass函数, 该函数第一个参数是结构体 objc_super(第一个参数是self, 第二个参数是当前实例变量的super_class, 就是Father类). 然后直接从实例变量所在类的父类(Father)去找- (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用, 此时已经和[self class]调用相同了, 故上述输出结果仍然返回 Son. isKindOfClass与isMemberOfClass1234567BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Father class] isKindOfClass:[Father class]];BOOL res4 = [[Father class] isMemberOfClass:[Father class]];NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); 结果： 12017-07-23 13:03:38.053683+0800 Runtime[2262:176716] 1 0 0 0 内部实现： 1234567891011121314151617181920212223242526272829+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj) &#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;- (BOOL)isKindOf:(Class)cls &#123; Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isMemberOf:(Class)cls &#123; return [self class] == cls;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125; res1：[NSObject class]返回NSObject,接着执行 + isKindOfClass, object_getClass((id)self)返回的是NSObject的isa 也就是NSObject 的meta class,所以第一次循环判断不等，第二次tcls = tcls-&gt;superclass也就是NSObject所以相等.结果为YES. res2：[NSObject class]返回NSObject,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO res3：[Father class]返回Father,接着执行 + isKindOfClass, object_getClass((id)self)返回的是Father的isa 也就是Father 的meta class,第二次tcls = tcls-&gt;superclass也就是NSObject的Meta Class,第三次是NSObject的Meta Class的superclass也就是NSObject,第四次是NSObject的superclass 为nil。退出循环，结果为NO. [Father class]返回Father,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO Category123456789101112131415161718下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface NSObject (Student) + (void)foo; - (void)foo; @end @implementation NSObject (Student) - (void)foo &#123; NSLog(@&quot;IMP: -[NSObject(Student) foo]&quot;); &#125;@end#import &quot;NSObject+Student.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; [NSObject foo]; [[NSObject new] foo]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 结果： 122017-07-23 13:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo]2017-07-23 13:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo] 分析：category中新增的方法, 如果是实例方法, 协议以及属性是直接添加到当前类上面, 如果是类方法和协议则会添加到当前类的原类上面去. 所以调用[NSObject foo]时, 由于是类方法, 根据objc_msgSend的相关知识, 会先在NSObject(Class)的isa中也就是NSObject的meta-class中, 去查找foo方法的IMP, 没找到, 然后去NSObject的meta-class的superclass(NSObject)中找, 找到了, 执行foo方法. 调用[[NSObject new] foo]时, 会先在NSObject(Object)的isa中, 也就是NSObject(Class)中找, 找到了, 直接执行, 输出结果. Runtime的常见用法Method SwizzlingMethod Swizzling本质上就是对IMP和SEL进行交换, 当Method Swilzzling代码执行完毕之后互换才起作用, Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式. 我们替换ViewController的viewWillAppear:方法为例, 使用方式如下: 123456789101112131415161718192021222324252627@implementation ViewController (MethodSwizzling)+ (void)load &#123; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; Class class = [self class]; //这里需要注意, 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //我们先把要替换的类添加到category中 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; //class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; //交换IMP, IMP是函数指针, 直接指向方法的内存地址 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@&quot;%@ viewWillAppear&quot;, self);&#125;@end 这里有几点是要注意的: Objective-C在运行时会自动调用类的两个方法+load和+initialize. +load会在类初始加载时调用, +initialize方法是以懒加载的方式被调用的, 只有当你给某个类或它的子类发送消息, 那么这个类的+initialize方法才会被调用. 所以Swizzling要写在+load方法中, 因为写在+initialize方法中, 是有可能永远都不被执行. Swizzling应该只被执行一次, 如果Swizzling的方法被多次执行, 那么就有可能造成Swizzling失效, 所以我们要用dispatch_once来保证只被执行一次. Swizzling在+load中执行时, 不要调用[super load]. 如果是多继承, 并且对同一个方法都进行了Swizzling, 那么调用[super load]以后, 父类的Swizzling就失效了. 在swizzling的过程中, 方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中. 这时不会产生无限循环. 如果我们调用的是[self viewWillAppear:animated], 因为viewWillAppear:被重定向到xxx_viewWillAppear:, 就会产生无限循环. 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. 我们也可以使用这个来做一些异常保护, 例如数组的越界问题, 我们可以Swizzling数组的objectAtIndex:方法, 在新方法中做一些异常处理, 来抛出一些异常信息, 方便我们定位问题. NSCoding的自动归档和自动解档主要思路是获取成员变量列表, 利用KVC读取和赋值来完成encodeWithCoder和initWithCoder. 123456789101112131415161718192021222324252627282930#import &quot;Student.h&quot;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation Student- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125;&#125;- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; return self;&#125;@end 参考资料： 神经病院 Objective-C Runtime 入院系列 Objective-C Runtime Objective-C Runtime 运行时系列 iOS 如何实现 Aspect Oriented Programming Method Swizzling 和 AOP 实践 刨根问底Objective－C Runtime 深入理解Objective-C：Category Objective-C 消息发送与转发机制原理","path":"2017/07/23/runtime实践/","date":"07-23","excerpt":""},{"title":"iOS中的runtime","text":"Objective-C是C的语言的超集,C是一门静态语言而Objective-C却是一门动态语言,这个动态特性就是由基于Smalltalk消息传递特性的Runtime来提供的.纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 Runtime简介Objective-C在三种层面上与Runtime系统进行交互: 通过 Objective-C 源代码Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码, 在运行时确定对应的数据结构和调用具体哪个方法. 通过 Foundation 框架的 NSObject 类定义的方法NSObject类是遵守NSObject协议的, 在这个协议里面有很多方法是和Runtime相关, 或者直接从Runtime中获取信息的. 通过对 Runtime 库函数的直接调用在这里需要注意一下, 系统本身是默认关闭了Runtime的代码提示的, 我们需要在BuildSettings -&gt; Enable Strict Checking objc_msgSend Calls -&gt;设置为NOObjective-C 的 Runtime 为我们提供了很多运行时状态下跟类与对象相关的函数,具体的可以看Objective-C Runtime Reference. Runtime 基础数据结构Object(对象), Class(类), Meta Class(原类), id. 通过objc_class的定义我们大致可以看出他们之间的关系: 12345678910111213141516171819202122232425typedef struct objc_class *Class; typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123; private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; id在Objective-C中可以代指任意的对象类型，他是一个指向objc_object结构体的指针（typedef struct objc_object *id;这个struct的定义本身就带了一个 , 所以我们在使用其他NSObject类型的实例时需要在前面加上 , 而使用 id 时却不用） 那么什么是 objc_object 呢? Objective-C中的Object(objc_object)在最后会被转换成C的结构体, 而在这个struct中有一个 isa_t 类型的结构体isa, 通过查看 isa_t 我们发现它里面有一个指向它的类别 Class(定义了对象所属的类). 注意: isa 指针不总是指向实例对象所属的类, 不能依靠它来确定类型, 而是应该用 class 方法来确定实例对象的类. 123456789101112struct objc_object &#123; private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor);&#125; 3.那么什么是 Class 呢? Class 其实是一个指向 objc_class 结构体的指针（typedef struct objc_class *Class;） 123456struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; 总结: Class在设计中本身也是一个对象. 而这个Class对象的对应的类, 我们叫它 Meta Class, 它用来表述类对象本身所具备的元数据, 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法. 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 即Class结构体中的 isa 指向的就是它的 Meta Class. 我们可以把Meta Class理解为一个Class对象的Class. 当我们给一个NSObject对象发送消息时(实例方法), 这条消息会在对象所属的类的方法列表里查找. 当我们发送一个消息给一个类时(类方法), 这条消息会在类的Meta Class的方法列表里查找. 下面这个图很好地说明了Object, Class, Meta Class之间的关系. 每个实例(Object)的isa指针都指向该实例所属的类. 每个类(Class)的isa指针都指向为一个该类所属的Meta Class(原类). 每个Meta Class(原类)的isa指针都指向Root Class(Meta)(根原类), 大部分情况是都是NSObject. Root class(meta)的superclass指向Root class(Class), 也就是NSObject, 形成一个回路. Root class(Class)其实就是NSObject, NSObject是没有超类的, 所以Root class(Class)的superclass指向nil. isa_tobjc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体. 因为 isa_t 使用 union 实现, 所以可能表示多种形态, 既可以当成是指针, 也可以存储标志位. 有关 isa_t 联合体的更多内容可以查看Objective-C 引用计数原理. 1234567union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; cache_tcache_t 出现在 objc_class 中, cache_t 中存储了一个 bucket_t 的结构体 _buckets ，和两个unsigned int 的变量 _mask 和 _occupied. _mask 分配用来缓存bucket的总数, _occupied 表明目前实际占用的缓存bucket的个数. bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP. IMP是一个函数指针, 指向了一个方法的具体实现. bucket_t *_buckets其实就是一个散列表, 用来存储Method的链表. Cache 的作用主要是为了优化方法调用的性能. 当对象receiver调用方法message时, 首先根据对象receiver 的 isa 指针查找到它对应的类, 然后在类的 methodLists 中搜索方法, 如果没有找到, 就使用 super_class 指针到父类中的 methodLists 查找, 一旦找到就调用方法. 如果没有找到, 有可能消息转发, 也可能忽略它. 但这样查找方式效率太低, 所以使用Cache来缓存经常调用的方法, 当调用方法时, 优先在Cache查找, 如果没有找到, 再到methodLists查找. 123456789101112131415161718192021222324//cache_t结构struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125; typedef unsigned int uint32_t; typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t; typedef uintptr_t cache_key_t; struct bucket_t &#123; private: cache_key_t _key; IMP _imp;public: inline cache_key_t key() const &#123; return _key; &#125; inline IMP imp() const &#123; return (IMP)_imp; &#125; inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125; inline void setImp(IMP newImp) &#123; _imp = newImp; &#125; void set(cache_key_t newKey, IMP newImp);&#125; class_data_bits_t1234567891011121314151617181920212223242526272829303132333435363738394041424344//class_data_bits_t结构struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125; struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125; struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 上面这张图很好地说明了 class_data_bits_t 的作用. 详见深入解析 ObjC 中方法的结构. 大致说明一下就是, Objc的类的属性, 方法, 以及遵循的协议在obj 2.0的版本之后都放在 class_rw_t 中. class_ro_t 是一个指向常量的指针, 存储来编译器决定了的属性、方法和遵守协议. 在运行时发消息时, 会从 class_data_bits_t 调用 data 方法, 将结果从 class_rw_t 强制转换为 class_ro_t 指针. 最后调用 methodizeClass 方法, 把类里面的属性, 协议, 方法都加载进来. 方法与消息SELSEL 又叫做方法选择器, 是表示一个方法的 selector 的指针, 定义如下: 1typedef struct objc_selector *SEL; OC在编译时，会依据每一个方法的名字，参数序列，生成一个唯一整形标识（Int类型的地址），这个标识就是SEL.不同类的不同方法，只要方法名相同，哪怕参数类型不同，这两个方法的SEL就是一样的.同一个类中就不能存在两个方法名一致，参数不一致，这样编译器就会报错.但不同的类就可以，因为不同类的实例对象执行方法时，是从各自类的方法列表中根据selector去寻找自己对应的IMP. 工程中所有的SEL组合成一个set集合，因此SEL是唯一的.set中的元素都是唯一的，所以SEL也是唯一的，所以我们找一个selector，通过他对应的SEL是最快的方法.SEL实际就是根据方法名Hash过的一个字符串（这也解释了上面相同方法名编译为什么报错的原因），字符串的比较只需比较地址就可以了，速度非常快.本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度 我们可以在运行时添加和获取selector，也可以通过下面几种方法来获取SEL: 1231. sel_registerName函数2. Objective-C编译器提供的@selector()3. NSSelectorFromString()方法 IMPIMP实际上是一个函数指针，指向方法实现的地址，定义如下 1id (*IMP)(id, SEL,...) 该函数的第一个参数是self的指针，如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针.第二个参数是方法选择器，后面是方法的参数列表. 每个方法对应唯一的SEL，我们通过SEL就是为了查找方法的最终实现IMP，而IMP这个函数指针指向了最终的方法实现，取得IMP后，我们就获得了执行这个方法代码的入口点.通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现.这样就省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些. 通过一组id和SEL参数就能确定唯一的方法实现地址，而一个确定的方法也只有唯一的一组id和SEL参数 MethodMethod用于表示类定义中的方法，定义如下： 12345678910111213struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 我们可以看到，该结构体包含name(方法名，本质是IMP)，types(方法类型，本质是个char指针，存储方法的参数类型和返回值)，imp（方法指向，本质是个IMP，也可以说是函数指针）.该结构体实际上相当于在SEL和IMP之间做了一个映射，让我们可以通过SEL快速找到IMP. 成员变量与属性IvarIvar用来表示实例变量，其实际是一个指向objc_ivar结构体的指针，定义如下： 12345678910111213typedef struct objc_ivar *Ivar;struct ivar_t &#123; int32_t *offset;//表示基地址偏移字节 const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; 我们对ivar的访问就可以通过 对象地址 + lvar偏移字节的方法来访问，但是如果增加了父类的lvar，那怎么办，OC使用Non Fragile Ivars机制，Runtime会进行检测来调整类中新增的ivar的偏移量，这样我们就可以通过 对象地址 + 基类大小 + lvar偏移字节的方法计算出对应的ivar地址，并访问到相应的ivar，而不用重新编译子类 我们无法通过 -&gt;函数来修改私有属性，但是我们可以通过对象地址 + lvar偏移量来访问地址，获取指针后直接修改 属性实际就是lvar加上系统自动为我们生成的get和set方法 objc_property_t@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针: 1typedef struct property_t *objc_property_t; 需要注意的是，与 class_copyIvarList 函数不同, 使用 class_copyPropertyList 函数只能获取类的属性, 而不包含成员变量, 但此时获取的属性名是不带下划线的. 更多姿势可以看这里. protocol_t12345678910111213141516struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; ... 省略一些封装的便捷 get 方法&#125; CategoryCategory(分类), 他为现有的类提供了扩展, 它是 category_t 结构体的指针.详细查看深入理解Objective-C：Category 123456789typedef struct category_t *Category;typedef struct category_t &#123; const char *name;//类的名字 classref_t cls;//类 struct method_list_t *instanceMethods;//category中所有给类添加的实例方法的列表 struct method_list_t *classMethods;//给所有类添加类方法的列表 struct protocol_list_t *protocols;//所有协议的列表 struct property_list_t *instanceProperties;//category中添加的所有属性的列表&#125; category_t; 从category的定义可以看出我们可以添加实例方法，类方法，甚至可以实现协议，添加属性，但是无法添加实例变量 在App的启动过程中，会在_read_images函数间接调用到attachCategories函数，完成向类中添加Category的工作，向class_rw_t中的method_array_t，property_array_t，protocol_array_t 数组中分别添加method_list_t，property_list_t，protocol_list_t指针.把category的实例方法, 协议以及属性添加到类上, 把category的类方法和协议添加到类的metaclass上. 我们需要注意的是： category不会覆盖原类中的方法，而是两个都存在，但是category的在前面，按照方法列表来找，找到category的之后, 就不再往下找了, 造成被覆盖的假象. 附加category的类的工作会先于+load方法的执行. +load的执行顺序是先类, 后category, 而category的+load执行顺序是根据编译顺序(Compile Sources中的顺序)决定的. 消息查找与转发Objective-C中任何方法的调用, 编译器都会将[receiver message]转化为一个消息函数的调用, 即objc_msgSend, 消息直到运行时才绑定到方法的实现上. objc_msgSend 的定义如下: 1objc_msgSend(receiver, selector, arg1, arg2, ...) 消息的查找和动态解析 判断 selector 是不是需要被忽略的垃圾回收用到的方法, 是的话就忽略, 不是的话继续下一步操作. 判断target是不是nil, 如果这里有相应的nil的处理函数, 就跳转到相应的函数中. 如果没有处理nil的函数, 就自动清理现场并返回. 这一点就是为何在OC中给nil发送消息不会崩溃的原因. 查找当前类的缓存, 如果命中缓存获取到了IMP就将IMP返回, 如果没有继续下一步操作. 在当前类的方法列表中查找(根据 selector 查找到 Method 后, 获取 Method 中的 IMP), 对已经排序的列表使用二分法查找, 未排序的列表则是线性遍历. 如果找到把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在继承层级中递归向父类(一直到 NSObject 为止)中查找, 情况跟上一步类似, 也是先查找缓存, 缓存没中就查找方法列表, 查到后就终止递归查询, 把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在消息查找阶段, 如果没找到IMP(也就是接收到未知的消息), 会进入动态方法解析阶段, 首先会调用所属类的+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)方法. 前提是我们必须自己实现该方法, 并且添加到类里面. 1234567891011void functionForMethod1(id self, SEL _cmd) &#123; NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125; + (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123; class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125; 此时如果既没有没查找到 IMP, 动态方法解析也不奏效, 那么就进入了下一个阶段-消息转发阶段. 消息的转发上面主要是消息的查找阶段主要完成的是通过select()快速查找IMP的过程, 接下来才是消息的转发阶段, 到了转发阶段, 会调用到了转发阶段, 会调用id _objc_msgForward(id self, SEL _cmd,…)方法. 在执行_objc_msgForward之后会调用 __objc_forward_handler函数. 它的实现大致如下: 12345678// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel) &#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self);&#125; 当我们给一个对象发送一个没有实现的方法的时候, 如果其父类也没有这个方法, 则会崩溃, 报错信息类似于这样: unrecognized selector sent to instance, 然后接着会跳出一些堆栈信息. 这些信息就是从这里而来. 如果上面的查找和解析都失败的话, 消息就会无法处理, 这是Runtime会调用以下方法: 1- (id)forwardingTargetForSelector:(SEL)aSelector 我们可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来把消息的接受者换成一个可以处理该消息的实例对象或者类对象. 示例如下: 12345678910111213- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(Method:))&#123; return otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@&quot;Class name&quot;); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果一个对象实现了这个方法, 并返回一个非nil的结果, 则这个对象会作为消息的新接收者, 且消息会被分发到这个对象.当然这个对象不能是self自身, 否则就是出现无限循环.如果我们没有指定相应的对象来处理aSelector, 则应该调用父类的实现来返回结果. 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上, 但这一步无法对消息进行处理, 如操作消息的参数和返回值. 如果在上一步还不能处理未知消息, 则唯一能做的就是启用完整的消息转发机制了. 运行时系统会给消息接收者最后一次机会将消息转发给其它对象. 我们首先要通过, 指定方法签名, 若返回nil, 则表示不处理. 123456- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123; return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector: aSelector];&#125; 若返回方法签名, 则会进入下一步调用. 12345678- (void)forwardInvovation:(NSInvocation)anInvocation &#123; if ([someOtherObject respondsToSelector: [anInvocation selector]]) &#123; [anInvocation invokeWithTarget:someOtherObject]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 该方法对象会创建一个表示消息的NSInvocation对象,把与尚未处理的消息有关的全部细节都封装在anInvocation中, 包括selector, 目标(target)和参数. 我们可以在forwardInvocation方法中选择将消息转发给其它对象. 我们可以通过anInvocation对象做很多处理, 比如修改实现方法, 修改响应对象等. 这个方法的主要作用是定位可以响应封装在anInvocation中的消息的对象(这个对象不需要能处理所有未知消息). 使用anInvocation作为参数, 将消息发送到选中的对象. anInvocation将会保留调用结果, 运行时系统会提取这一结果并将其发送到消息的原始发送者. 在这个方法中我们也可以实现一些更复杂的功能, 我们可以对消息的内容进行修改, 比如追回一个参数等, 然后再去触发消息. 另外, 若发现某个消息不应由本类处理, 则应调用父类的同名方法, 以便继承体系中的每个类都有机会处理此调用请求. 上面两个补救措施做完后, 若发现某调用不应由本类处理, 则会调用超类的同名方法. 如此, 继承体系中的每个类都有机会处理该方法调用的请求, 一直到NSObject根类. 如果到NSObject也不能处理该条消息, 那么就是再无挽救措施了, 只能抛出”doesNotRecognizeSelector”异常.","path":"2017/07/18/runtime/","date":"07-18","excerpt":""},{"title":"UIView介绍","text":"生命周期创建View时： initWithFrame: initWithFrame进行初始化时, 当rect的值不为CGRectZero时会触发layoutSubviews. init初始化不会触发layoutSubviews. willMoveToSuperview: 当视图即将加入父视图时 / 当视图即将从父视图移除时调用 didMoveToSuperview: 当试图加入父视图时 / 当视图从父视图移除时调用 willMoveToWindow: 当视图即将加入父视图时 / 当视图即将从父视图移除时调用 didMoveToWindow: 当试图加入父视图时 / 当视图从父视图移除时调用 layoutSubviews: 在子视图布局变动时会多次调用 当View销毁时: willMoveToWindow didMoveToWindow willMoveToSuperview didMoveToSuperview removeFromSuperview dealloc 如果View中有子View的话, 创建时除了上面的顺序之外, 还会调用: layoutSubviews, 这是因为子视图的布局变动, 所以会触发. didAddSubview drawRect 移除时, 除了上面的顺序之外, 还会调用willRemoveSubview, 是在dealloc后面执行的. 如果有多个子视图, willRemoveSubview会循环执行, 直到移除所有子视图. UIView和CALayer UIView继承于UIResponder,可以响应触摸事件. CALayer继承于NSObject,不能响应触摸事件. UIView主要是对显示内容的管理, CALayer主要侧重显示内容的绘制.所以访问UIView与绘图相关属性（frame,bounds）等实际上内部都是在访问它所包含的CALayer的相关属性.UIView的创建实际上是一系列CALayer创建的过程. UIView有个重要属性layer. 可以返回它的主CALayer实例. 所有从UIView继承来的对象都继承了这个属性. 这意味着你可以在所有的UIVIew子类上增加动画, 旋转, 缩放等CALayer支持的操作. UIView的layerClass方法, 可以返回主layer所使用的类, UIView的子类可以通过重载这个方法, 来让UIView使用不同的CALayer来显示. 代码示例： 123- (class)layerClass &#123; return ([CAEAGLLayer class]);&#125; UIView的主CALayer是类似于subviews的树形结构, 我们可以通过给主layer添加子layer来完成特殊的绘制效果.在view上添加一个黑色透明layer层的示例代码: 123grayCover = [[CALayer alloc] init];grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];[self.layer addSubLayer:grayCover]; UIView的内部, 有三个layer tree: 1.逻辑树, 这里是代码可以操纵的. 2.动画树, 是一个中间层, 系统就在这一层上通过逻辑树来更改属性, 进行各种渲染操作. 3.显示树, 其内容就是当前正被显示在屏幕上得内容. UIView实际上是CALayer的CALayerDelegate, 通过实现一系列的代理方法来显示CALayer绘制的内容. 在做 iOS 动画的时候, 修改非RootLayer的属性(譬如位置, 背景色等)会默认产生隐式动画, 而修改UIView则不会. layer可以设置圆角显示(cornerRadius), 也可以设置阴影(shadowColor). 但是如果layer树中某个layer设置了圆角, 树种所有layer的阴影效果都将不显示了. 因此若是要有圆角又要阴影, 变通方法只能做两个重叠的UIView, 一个的layer显示圆角, 一个layer显示阴影. UIView 是UIKit框架下的(只能iOS使用). CALayer 是QuartzCore的(iOS 和macOS通用). QuartzCore的渲染能力. 使二维图像可以被自由操纵, 就好像是三维的. 图像可以在一个三维坐标系中以任意角度被旋转, 缩放和倾斜. CATransform3D的一套方法提供了一些魔术般的变换效果.参考链接：详解CALayer 和 UIView的区别和联系,UIView和CALayer的区别 drawRect该方法默认没有任何操作代码,如果视图中包含我们用UIKit或者Core Graphics绘制的内容, 我们需要重写该方法. 当视图第一次出现, 或者是改变约束条件让视图的全部或者一部分在屏幕上发生变化时, 系统都会调用UIView类的drawRect方法. 然后我们在此方法中能过获取到当前图形上下文, 实现我们的绘制内容, 最后系统会在合适的时机自动调用此方法. drawRect一般调用是在UIView的layoutSubviews方法执行后.但是, 在我们的视图全部初始化后,如果视图又发生了改变, 此时视图就需要重绘, 但是系统不会再帮我们自动调用drewRect方法. 这个时候就需要我们手动调用UIView类的 setNeedsDisplay或setNeedsDisplayInRect方法. 这两个方法是用来告诉系统, 我们的视图有了更新需要去重绘. 相当于是给系统做了标记, 在系统 runloop 的下一个周期自动调用drawRect方法. 使用中要注意的地方: 不要直接调用 drawRect 方法,如果强行调用此方法也是无效果的.苹果要求我们调用 UIView 类的 setNeedsDisplay 方法,则程序会自动调用 drawRect 方法进行重绘. 因为在绘制时要拿到图形上下文,如果在 UIView 初始化时没有设置 rect 大小, drawRect 方法不会被调用. 调用 sizeThatFits 后, 控件 frame 改变, UIView 的 layoutSubviews 被调用, 然后再调用 drawRect 方法. 所以可以先调用 sizeToFit 计算出size. 然后系统自动调用 drawRect 方法. 通过设置 contentMode 属性值为 UIViewContentModeRedraw.那么将在每次设置或更改 bounds 的时候自动调用 drawRect. 若要实时画图, 如果使用 gestureRecognizer 来刷新屏幕, 需要判断并转化 point 的坐标; 使用 touchbegan 等方法, 只需调用 setNeedsDisplay 实时刷新屏幕. 参考资料：使用drawRect:实现绘制画板功能的内存优化 sizeToFit, sizeThatFitssizeToFit：当我们想要resize当前View以便获取他合适的大小时, 我们需要调用该方法. 尤其是UIKit的View视图是根据内部需要进行尺寸调整时. 在某些情况下, 如果当前View没有父视图, 他会根据屏幕的bounds来resize自身大小. 如果你想让一个View根据父视图来调整大小, 必须将该View添加到父视图中.一般情况下, 我们不需要重写该方法, 如果你想改变当前View的default size, 我们通过重写sizeThatFits:来实现. 在sizeThatFits:方法中进行必要的计算, 返回结果, 然后改变他的大小. sizeThatFits：该方法要求View计算并返回最适合指定大小的大小. 传入的参数就是View需要最合适的大小, 返回值是根据传入的大小, 计算得到的一个最适合receiver子视图的尺寸.该方法默认返回视图的现有大小, 子类能够通过重写该方法获得一个基于该子类所有子视图的期望布局的自定义大小. 调用sizeThatFits:并不改变view的size, 它只是让view根据已有content和给定size计算出最合适的view.size. sizeToFit会自动调用sizeThatFits方法 sizeToFit不应该在子类中被重写, 应该重写sizeThatFits sizeThatFits传入的参数是receiver当前的size, 返回一个适合subviews的size sizeToFit可以被手动直接调用 sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己 调用 sizeToFit() 会去自动调用 sizeThatFits(_ size: CGSize) 方法 sizeThatFits 不会改变 receiver 的 size, 调用 sizeToFit() 会改变 receiver 的 size. 此处的receiver一般是方法的调用者 系统触发layoutSubviews的条件 父视图使用init方法完成初始化时不会触发layoutSubviews 父视图用initWithFrame完成初始化并且当frame参数为CGRectZero时不会触发layoutSubviews. 当frame参数不为CGRectZero时则会触发layoutSubviews 父视图setFrame的时候会触发layoutSubviews, 当然frame前后值得发生变化 父视图addSubview添加子视图时会触发其内部的layoutSubviews 子视图从父视图上removeFromSuperView的时候会触发其内部的layoutSubviews 滚动ScrollView的时候会触发layoutSubviews 旋转屏幕的时候会触发layoutSubviews 系统触发drawRect:的条件 如果在UIView初始化时没有设置rect大小, 将直接导致drawRect不被自动调用. drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的. 所以不用担心一进入到控制器中, 这些View的drawRect就开始画了. 这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值). 该方法在调用sizeToFit后被调用, 所以可以先调用sizeToFit计算出size, 然后系统自动调用drawRect:方法. 通过设置contentMode属性值为UIViewContentModeRedraw. 那么将在每次设置或更改frame的时候自动调用drawRect:. 直接调用setNeedsDisplay或者setNeedsDisplayInRect:触发drawRect:. 但是有个前提条件是rect不能为CGRectZero. 以上1, 2推荐; 而3, 4不提倡.","path":"2017/07/17/UIView介绍/","date":"07-17","excerpt":""},{"title":"UIViewController介绍","text":"生命周期 initWithCoder: 或 initWithNibName:bundle:, 首先从归档文件中加载UIViewController对象. 非StoryBoard创建调用initWithNibName:bundle:, 如果使用StoryBoard进行视图管理, 从nib中加载对象实例时, 程序不会直接初始化一个UIViewController, StoryBoard会自动初始化或在segue被触发时自动初始化initWithCoder:. awakeFromNib, 从xib或者storyboard加载完毕就会调用. loadView, 每次访问UIViewController的view(比如controller.view, self.view)而且view为nil, loadView方法就会被调用. loadView方法是用来负责创建UIViewController的view. 如果在初始化UIViewController指定了xib文件名, 就会根据传入的xib文件名加载对应的xib文件, 如果没有明显地传xib文件名, 就会加载跟UIViewController同名的xib文件. 如果没有找到相关联的xib文件, 就会创建一个空白的UIView, 然后赋值给UIViewController的view属性. 苹果设计这个方法就是给我们自定义UIViewController的view用的, 我们直接在该方法中指定UIViewController的View. viewDidLoad, 无论你是通过xib文件还是重写loadView方法创建UIViewController的view, 在view创建完毕后, 最终都会调用viewDidLoad方法. 在这里视图层次已经加载到内存中. 通常, 我们对于各种初始化数据的载入, 初始设定, 修改约束, 移除视图等很多操作都可以这个方法中实现. viewWillAppear:, 系统在载入所有的数据后, 将会在屏幕上显示视图, 这时会先调用这个方法, 通常我们会在这个方法对即将显示的视图做进一步的设置. viewWillLayoutSubviews, view 即将布局其Subviews. 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化), 要调整Subviews的位置, 在调整之前要做的工作可以放在该方法中实现. viewDidLayoutSubviews, view已经布局其Subviews, 这里可以放置调整完成之后需要做的工作. viewDidAppear:, 在view被添加到视图层级中以及多视图上下级视图切换时调用这个方法, 可以对正在显示的视图做进一步的设置. viewWillDisappear:, 当前视图在即将被移除, 或被覆盖时, 会调用该方法. 此时还没有调用removeFromSuperview. viewDidDisappear:, view已经消失或被覆盖, 此时已经调用removeFromSuperView. dealloc, UIViewController被销毁时调用, 此次需要对你在init和viewDidLoad中创建的对象进行释放. didReceiveMemoryWarning, 内存不够时, 系统会自动调用这个方法. 默认实现是如果当前UIViewController的view不在应用程序的视图层次结构(View Hierarchy)中, 即view的superview为nil的时候, 就会将view释放, 并且调用viewDidUnload方法. viewDidUnload, 收到内存警告时, 如果当前UIViewController的View的superView为nil时, 就会将View释放, 并且调用viewDidUnload. edgesForExtendedLayout, translucent, extendedLayoutIncludesOpaqueBars, automaticallyAdjustsScrollViewInsets edgesForExtendedLayout:iOS7以后 UIViewController 开始使用全屏布局，而且是默认的属性。通常涉及到布局，就离不开这个属性 edgesForExtendedLayout，它是一个类型为UIExtendedEdge的属性，指定UIViewController上的根视图self.view边缘要延伸的方向。由于iOS7鼓励全屏布局，所以它的默认值是UIRectEdgeAll，四周边缘均延伸，就是说，如果即使视图中上有UINavigationBar，下有UITabBar，那么视图仍会延伸覆盖到四周的区域。 12345678910typedef NS_OPTIONS(NSUInteger, UIRectEdge) &#123; UIRectEdgeNone = 0, UIRectEdgeTop = 1 &lt;&lt; 0, UIRectEdgeLeft = 1 &lt;&lt; 1, UIRectEdgeBottom = 1 &lt;&lt; 2, UIRectEdgeRight = 1 &lt;&lt; 3, UIRectEdgeAl = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight &#125; NS_ENUM_AVAILABLE_IOS(7_0); 设置为 UIRectEdgeNone就是不会延伸至UINavigationBar和UITabBar translucent:这个是self.navigationController.navigationBar的属性，设置导航条UINavigationBar是否半透明.默认是YES，也就是半透明. extendedLayoutIncludesOpaqueBars:不透明的条下是否可以扩展.默认为NO，也就是不可以扩展。当translucent设置为NO，即导航栏UINavigationBar不透明的时候，默认不能扩展(空出导航栏部分). automaticallyAdjustsScrollViewInsets: 自动校准滚动视图的嵌入视图,默认YES.automaticallyAdjustsScrollViewInsets根据按所在界面的status bar，navigationbar，与tabbar的高度，自动调整scrollview的 inset,设置为no，不让viewController调整，这种对于一个页面内有多个scrollView或者其子类十分有必要，我们自己修改布局即可. addchildviewcontrolleraddChildViewController是一个从iOS5开始支持的api接口，相关的一系列的接口是用来处理viewcontroller中嵌套显示其他viewcontroller的场景的。这样做的好处是: 对页面中的逻辑更加分明了。相应的View对应相应的ViewController. 当某个子View没有显示时，将不会被Load，减少了内存的使用. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制. 12345678910111213141516171819202122232425262728293031//在parent view controller 中添加 child view controller FirstViewController *firstViewController=[[FirstViewController alloc] initWithNibName:@&quot;FirstViewController&quot; bundle:nil];[self addChildViewController:firstViewController];SecondViewController *secondViewController=[[SecondViewController alloc] initWithNibName:@&quot;SecondViewController&quot; bundle:nil];[self addChildViewController:secondViewController];ThirdViewController *thirdViewController=[[ThirdViewController alloc] initWithNibName:@&quot;ThirdViewController&quot; bundle:nil];[self addChildViewController:thirdViewController];[self.view addSubview:thirdViewController.view]; // addChildViewController会调用[child willMoveToParentViewController:self] ，但是不会调用didMoveToParentViewController，所以需要xian调用[thirdViewController didMoveToParentViewController:self];currentViewController=thirdViewController;///////////////////////////////// * fromViewController 当前显示在父视图控制器中的子视图控制器 * toViewController 将要显示的姿势图控制器 * duration 动画时间(这个属性,old friend 了 O(∩_∩)O) * options 动画效果(渐变,从下往上等等,具体查看API) * animations 转换过程中得动画 * completion 转换完成 *///切换child view controller[self transitionFromViewController:currentViewController toViewController:firstViewController duration:4 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^&#123;&#125; completion:^(BOOL finished) &#123; //......&#125;];currentViewController=firstViewController; //移除child view controller// removeFromParentViewController在移除child前不会调用[self willMoveToParentViewController:nil] ，所以需要显示调用[currentViewController willMoveToParentViewController:nil];[currentViewController removeFromSuperview];[currentViewController removeFromParentViewController];","path":"2017/07/15/UIViewController介绍/","date":"07-15","excerpt":""},{"title":"UICollectionView刷新闪一下的问题","text":"UICollectionView在reloadItems的时候 默认会附加一个隐式的fade动画,有时候可能会闪一下，有时候item的大小会有一个从0到frame拉大效果。不管是哪种效果都显得非常的难看。 但是可以使用下面几种方法去掉UICollectionView隐式fade动画 1234567let time: TimeInterval = 0 DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) &#123; UIView.performWithoutAnimation &#123; self.collectionView.reloadData() &#125;&#125; 这样写有可能会造成一个问题，比方说在列表页下拉的同时又进行上拉，这种写法会造成reloadData()方法比正常的要有延迟，所以在下拉加载更多reloadData的时候cellforitem方法中可能上拉的数据返回，导致数组越界。这时需要在cellforitem方法中做一个越界判断避免程序crash","path":"2017/06/20/UICollectionView刷新闪一下的问题/","date":"06-20","excerpt":""},{"title":"UICollectionView自定义布局","text":"当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就可以考虑自定义layout。 【必须】定制UICollectionViewLayout必须覆盖的方法123- (void)prepareLayout;- (CGSize)collectionViewContentSize;- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; prepareLayout是专门用来准备布局的，在prepareLayout方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。此方法在布局之前会调用一次，之后只有在调用invalidateLayout,shouldInvalidateLayoutForBoundsChange:返回YES和UICollectionView刷新的时候才会调用. collectionViewContentSize返回内容尺寸给UICollectionView.这个方法返回的尺寸是给UICollectionView这个继承于UIScrollView的视图作为contenSize,不是UICollectionView的视图尺寸.这个方法会多次调用，所以最好是在prepareLayout里就计算好。 layoutAttributesForElementsInRect方法返回一组UICollectionViewLayoutAttributes类对象.它代表着在这个指定的区域中，我们需要显示cell,Supplementary View 和 Decoration View中哪些视图，而这些视图的属性则保存UICollectionViewLayoutAttributes中.此方法会多次调用，为了更好的性能，在这个方法当中，我们使用的UICollectionViewLayoutAttributes最好是在prepareLayout已经布局好的信息。 【可选】交互定制方法12- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; shouldInvalidateLayoutForBoundsChange:当布局的边界发送改变的时候，会询问该方法是否重新布局.一旦重新刷新布局，就会按顺序调用下面的方法: prepareLayout,layoutAttributesForElementsInRect. targetContentOffsetForProposedContentOffset返回值决定collectionView在停止滚动的时候最终的偏移量contentOffset（常见的卡片布局会使用到） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)prepareLayout&#123; [super prepareLayout]; NSMutableArray *layoutInfoArr = [NSMutableArray array]; NSInteger maxNumberOfItems = 0; //获取布局信息 NSInteger numberOfSections = [self.collectionView numberOfSections]; for (NSInteger section = 0; section &lt; numberOfSections; section++)&#123; NSInteger numberOfItems = [self.collectionView numberOfItemsInSection:section]; NSMutableArray *subArr = [NSMutableArray arrayWithCapacity:numberOfItems]; for (NSInteger item = 0; item &lt; numberOfItems; item++)&#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section]; UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:indexPath]; [subArr addObject:attributes]; &#125; if(maxNumberOfItems &lt; numberOfItems)&#123; maxNumberOfItems = numberOfItems; &#125; //添加到二维数组 [layoutInfoArr addObject:[subArr copy]]; &#125; //存储布局信息 self.layoutInfoArr = [layoutInfoArr copy]; //保存内容尺寸 self.contentSize = CGSizeMake(maxNumberOfItems*(self.itemSize.width+self.interitemSpacing)+self.interitemSpacing, numberOfSections*(self.itemSize.height+self.lineSpacing)+self.lineSpacing);&#125;//itemSize是cell的大小，interitemSpacing是cell与cell之间的间距，lineSpacing是行距。- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //每一组cell为一行 attributes.frame = CGRectMake((self.itemSize.width+self.interitemSpacing)*indexPath.row+self.interitemSpacing, (self.itemSize.height+self.lineSpacing)*indexPath.section+self.lineSpacing, self.itemSize.width, self.itemSize.height); return attributes;&#125;- (CGSize)collectionViewContentSize&#123; return self.contentSize;&#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray *layoutAttributesArr = [NSMutableArray array]; [self.layoutInfoArr enumerateObjectsUsingBlock:^(NSArray *array, NSUInteger i, BOOL * _Nonnull stop) &#123; [array enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if(CGRectIntersectsRect(obj.frame, rect)) &#123; [layoutAttributesArr addObject:obj]; &#125; &#125;]; &#125;]; return layoutAttributesArr;&#125;","path":"2017/06/16/UICollectionView自定义布局/","date":"06-16","excerpt":""},{"title":"Cocoapods","text":"Cocoapods概念Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. Cocoapods的实现原理cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一Podfile. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。 Podfile source: spec的地址 platform: 指定构建静态库的平台 target: 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项 pod: 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的 执行完pod install 命令之后，可以发现工程里面多了三个文件, 一个XXX.xcworkspace文件, 一个Podfile.lock文件, 还有一个Pods文件夹. xcworkspace：管理新生成的Project和原本的Project Podfile.lock：记录各个Pod的版本号和之前的依赖关系 Pods： 新生成库的源代码 创建一个Spec RepoSpec Repo是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的: ├── Specs└── [SPEC_NAME]└── [VERSION]└── [SPEC_NAME].podspec如果你要创建私有Pod, 那么你的Spec Repo的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]来把远端的仓库clone到本地. 注意, 这里[Spec Repo的仓库名]不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交PodSpec文件时用到. 创建Pod工程文件我们在你需要创建Pod的目录下使用pod lib create [Pod名称]来创建对应的Pod模板. 实际上该命令行隐藏了默认参数, 参数补全后应该是pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git. 接下来会问你四个问题: What language do you want to use?? [ Swift / ObjC ]. 使用什么语言 Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架 Would you like to do view based testing? [ Yes / No ]. 是否基于View测试 What is your class prefix?. 类的前缀根据自己的实际需要来选择后, 就会自动执行Pod install命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:MyLib├── .travis.yml├── _Pods.xcproject├── Example│ ├── MyLib│ ├── MyLib.xcodeproj│ ├── MyLib.xcworkspace│ ├── Podfile│ ├── Podfile.lock│ ├── Pods│ └── Tests├── LICENSE├── MyLib.podspec├── Pod│ ├── Assets│ └── Classes│ └── RemoveMe.[swift/m]└── README.md接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库: 1234$ git add .$ git commit -s -m “Initial Commit of Library”$ git remote add origin [Pod的远端地址] #添加远端仓库$ git push origin master #提交到远端仓库 编辑Pod文件Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是Assets, 一个是Classes. Assets文件主要用来存放资源文件, 例如图片资源和XIB文件. Classes则存放主要的功能代码, 类.在这里需要注意两个地方: 当我们要使用Pod中的资源时, 以图片为例, 我们通过[UIImage imageWithName:@&quot;xxx.png&quot;]是取不到Pod中的图片的, 因为imageWithName:方法默认是从mainBundle中来取的, 而Pod不属于mainBundle的范畴, 我们需要先根据class来拿到当前类所在的bundle, 再取该Bundle中的资源. 每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行pod update命令来重新建立索引. 编辑Podspec文件初始时的Podspec文件包含了各种信息, 详细的说明我们可以看官方文档,这里贴上最基础的用法代码 123456789101112131415161718192021222324252627282930313233Pod::Spec.new do |s|s.name = ‘LevinPods’#Pod的版本s.version = ‘0.1.0’s.summary = ‘你在搜索时会呈现’s.description = &lt;&lt;-DESC这里是关于你Pod功能的描述DESCs.homepage = ‘https://github.com/HChong3210/HCPods‘s.license = &#123; :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ &#125;s.author = &#123; ‘LevinLuo’ =&gt; ‘786325209@qq.com’ &#125;#Pod的远端仓库地址s.source = &#123; :git =&gt; ‘https://github.com/xxx/LevinPods.git‘, :tag =&gt; s.version.to_s &#125;#Pod支持的最低版本s.ios.deployment_target = ‘8.0’#Pod源文件的位置s.source_files = ‘LevinPods/Classes/*/‘#Pod中资源文件的位置s.resource_bundles = &#123;‘DFCForms’ =&gt; [‘LevinPods/Assets/*.&#123;png,xib,plist&#125;’]&#125;#对外公开的类s.public_header_files = ‘DFCForms/Classes/*/.h’#Pod中用到的第三方库s.frameworks = ‘UIKit’s.dependency ‘AFNetworking’, ‘~&gt; 2.3’s.dependency ‘SDWebImage’end 提交Pod文件Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, 注意, 这里的Tag必须和Podspec文件中的Pod版本号一致 , 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码: 12345git statusgit add .git tag -m ‘备注’ 版本号git commit -s -m ‘备注’git push origin master —tags 提交Podspec文件提交完Pod文件后, 我们只用把Podspec文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了.在提交之前我们可以在根目录下使用pod lib lint命令来验证是否编译通过. 也可以直接提交pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose subspec的使用有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在Podspec文件中这样设置: 1234567s.subspec ‘[子Pod名称]’ do |pod1|pod1.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘ends.subspec ‘[子Pod名称]’ do |pod2|pod2.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘end 我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency. 我们在外面引用该Pod的时候就可以使用pod [Pod/子Pod]的方式来只引用一个子Pod. 常见Pod依赖的几种写法pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]pod ‘QueryKit/Attribute’pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’pod ‘AFNetworking’, :git =&gt; ‘https://github.com/gowalla/AFNetworking.git‘pod ‘JSONKit’, :podspec =&gt; ‘https://example.com/JSONKit.podspec‘ 参考资料 Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验 细聊Cocoapods与Xcode工程配置 使用Cocoapods创建私有podspec CocoaPods 都做了什么？ 使用私有Cocoapods仓库中引用.a库 深入理解CocoaPods","path":"2017/06/03/Cocoapods/","date":"06-03","excerpt":""},{"title":"iOS项目工程概念","text":"Xcode Workspaceworkspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件. 一个workspace可以管理多个Project,pod install的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project. Xcode Projectproject就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。 Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。 project包含了以下信息： 源文件 代码的头文件和实现文件 静态库，动态库 资源文件(如图片，文本，xml，plist等) 界面资源文件(xib， storyboard等) 在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹) project的编译级别配置文件如(debug， release) target 运行环境如：debug，test project可以单独存在，或者存在于一个workspace中. Xcode Targettarget 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product. 这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效. target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。 指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置. Scheme一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme. scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 Build Settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准 一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。 除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.关于继承关系，The Unofficial Guide to xcconfig files这里也有详细的说明，强烈建议阅读。动态环境配置就是使用自定义的 build settings 来实现的. 参考资料: Xcode使用xcconfig文件配置环境 Apple官方文档 Xcode中的Scheme和Build Configuration Xcode workSpace 多个project联编","path":"2017/05/11/iOS项目工程概念/","date":"05-11","excerpt":""},{"title":"Instruments使用","text":"Instruments 是 Xcode 提供我们调试App性能的分析工具 打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面 Core AnimationCore Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿. Color Blended Layers，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。 Color Hits Green and Misses Red，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。 Color Copied Images，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。 Color Non-Standard Surface Formats, 不标准的表面颜色格式. Color Immediately，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。 Color Misaligned Images，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。 Color Offscreen-Rendered Yellow，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。 Color Compositing Fast Path Blue，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。 Flash Updated Regions，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。 Leaks关于内存方面的监控, 有Leaks用来检测内存泄漏, Zombies用来检测僵尸对象. 关于内存泄漏常见的几种情况, 可以参考这里 Time Profiler这个主要是用来统计各个方法消耗的时间.如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的. Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Time Profiler无法定位到代码 Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File Profile要在debug模式下运行, BuildConfiguration要选择debug. 参考资料 iOS 性能优化：Instruments 工具的救命三招 Instruments性能优化-Core Animation 使用 Instruments 做 iOS 程序性能调试 关于内存泄漏，还有哪些是你不知道的？ 使用Instruments定位iOS应用的Memory Leaks instrument Time Profiler总结","path":"2017/04/28/Instruments使用/","date":"04-28","excerpt":""},{"title":"iOS内存分配","text":"计算机系统中，应用程序的数据都保存在内存中，不同的数据类型保存的区域也不同。 RAM和ROM RAM：运行时内存，程序在运行过程中的使用的内存，不能掉电存储 ROM：存储形内存（内存卡），RAM的速度和价格都高于ROM App程序启动，系统会把存储在ROM中的程序拷贝到RAM中，然后从内存里面执行代码 内存分区堆区：Heap堆区由程序员来分配(oc: alloc swift: init)和释放 ARC下的内存管理由编译器自动添加retain, release, autorelease等关键字 堆区的地址由低到高分配 不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理) 堆空间的分配总是动态的 需要程序猿进行分配和释放 栈区 Stack栈区是由编译器自动分配和释放的，用来存放局部变量，函数的参数值，函数跳转地址等iPhone栈区大小是512K 不需要我们管理栈区变量的内存 栈区地址从高到低分配 先进后出栈空间有静态分配和动态分配两种 静态分配是由编译器完成，比如自动变量auto的分配. 动态分配由alloca函数完成. 栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配. 全局区 static全局区也叫做静态区，全局变量和静态变量在内存中是存放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和静态变量放在相邻的宁一块区域，程序结束后由系统释放 常量区存放字符串常量，程序结束后由系统自己释放 代码区代码区用于存放函数的二进制代码，App的代码，程序结束后由系统释放 内存分区地址如图所示：代码区的地址最低，栈区最高，但区与区之间的地址不连续 栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便. 系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容). 变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回. 当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃. 申请内存后系统的响应 栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小. 堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去. 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.堆获得的空间比较灵活, 也比较大.","path":"2017/04/14/iOS内存分配/","date":"04-14","excerpt":""},{"title":"git工作流","text":"大话 Git 工作流,这篇文章非常有意思，用故事的方法描述了几种常用的git工作流程. 因为我们团队人数不多,所以我们的做法是这样的，建立master和developer分支。然后每个开发人员从developer分支上拉一个属于自己的远程分支，别人不会动你的远程分支，每次提交代码都提交到自己的远程分支。这样在每个人的角度便不会产生conflict。其实，多人协作开发，冲突是一个不可避免的问题。那么，一天工作结束的时候，我们再去解决冲突。remote1 pull remote2，在remote1中解决冲突，然后再push到developer分支，第二天上班的时候，每个人再从developer中pull最新的代码到本地。总的来说，分支模式，有利于对冲突的把控，不会影响到每一个人自己的代码。发布的时候developer分支合并到master分支上并打上tag.","path":"2016/12/29/git工作流/","date":"12-29","excerpt":""},{"title":"iOS网络编程","text":"HTTP请求中的GET和POSTGET把参数包含在URL中, POST通过request body传递参数.GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.GET/POST都是TCP链接 TCP与UDPTCP面向连接（如打电话要先拨号建立连接); UDP是无连接的, 即发送数据之前不需要建立连接.TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付. TCP: 面向连接, 传输可靠(保证数据正确性, 保证数据顺序), 用于传输大量数据(流模式), 速度慢, 建立连接需要开销较多(时间, 系统资源).UDP: 面向非连接, 传输不可靠, 用于传输少量数据(数据包模式), 速度快. 三次握手第一次握手: 建立连接, 客户端发送连接请求报文段, 将SYN位置为1, Sequence Number置为x; 然后, 客户端进入SYN_SEND状态, 等待服务器确认.第二次握手: 服务器收到SYN报文段, 服务器收到客户端的SYN报文段, 需要对这个报文段确认, 设置Acknowledgment Number为x+1(Sequence Number+1); 同时, 自己还要发送SYN请求信息, 将SYN位置为1, Sequence Number为y; 服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中, 一并发送给客户端, 此时服务器进入SYN_RECV状态.第三次握手: 客户端收到服务器的SYN+ACK报文段, 然后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, 客户端和服务器端都进入ESTABLISHED状态, 完成TCP三次握手. 完成了三次握手, 客户端和服务器端就可以开始传送数据. 四次挥手第一次挥手: 主机1(可以使客户端, 也可以是服务端), 设置Sequence Number和Acknowledgment Number, 向主机2发送一个FIN报文段; 此时，主机1进入FIN_WAIT_1状态; 这表示主机1没有数据要发送给主机2了.第二次挥手: 主机2收到了主机1发送的FIN报文段, 向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1; 主机1进入FIN_WAIT_2状态; 主机2告诉主机1, 我”同意”你的关闭请求.第三次挥手: 主机2向主机1发送FIN报文段, 请求关闭连接, 同时主机2进入LAST_ACK状态.第四次挥手: 主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态; 主机2收到主机1的ACK报文段以后, 就关闭连接; 此时, 主机1向等待2MSL后依然没有收到回复, 则证明主机2已经正常关闭, 那么主机1也就此关闭. HTTP与HTTPSHTTPS的主要思想是在不安全的网络上创建一安全信道, 并可在使用适当的加密包和服务器证书可被验证且可被信任时, 对窃听和中间人攻击提供合理的防护. HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构.HTTPS中的S指的就是TLS(SSL), 相当于是HTTP over SSL. 使用SSL/TLS协议进行加解密, 下面我们来详细说一下是如何加密的. HTTP默认端口是80, HTTPS默认端口是443. 客户端向服务端发出加密请求, 服务端用自己的私钥加密后, 连同数字证书一起发送给客户端. 客户端(浏览器)中内置有证书管理器, 有”受信任的根证书颁发机构”列表. 客户端会根据这张表查看解开数字证书的公钥是否在列表内. 如果数字证书记载的网址与浏览的不一致, 就说明这张证书被冒用, 浏览器会发出警告. 如果这张数字证书不是由受信任的机构颁发的, 浏览器会发出另一种警告(12306)就是第二种警告. 如果数字证书是可靠的, 客户端就可以使用证书中的服务器公钥, 对信息进行加密, 然后与服务器交换加密信息.","path":"2016/10/20/iOS网络编程/","date":"10-20","excerpt":""},{"title":"iOS事件响应链","text":"流程 触摸屏产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中去. UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keywindow） 主窗口会在视图层级结构中找到一个最合适的View来处理触摸事件 最合适的View调用自己的touches方法处理事件 把事件沿着响应者链向上抛 注：事件的传递是从上到下（父控件到子控件）,事件响应是从下到上（子控件到父控件） 如何找到最合适的ViewhitTest:withEvent只要事件一传递给一个控件, 这个控件就会调用他自己的hitTest:withEvent:方法. 他的作用就是寻找并返回最合适的view(能够响应事件的那个最合适的view). 不管这个控件能不能处理事件, 也不管触摸点在不在这个控件上, 事件都会先传递给这个控件, 随后再调用 hitTest:withEvent:方法. 12345678910111213141516171819- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; // 1.判断当前控件能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // 2. 判断点在不在当前控件 if ([self pointInside:point withEvent:event] == NO) return nil; // 3.从后往前遍历自己的子控件 NSInteger count = self.subviews.count; for (NSInteger i = count - 1; i &gt;= 0; i--) &#123; UIView *childView = self.subviews[i]; // 把当前控件上的坐标系转换成子控件上的坐标系 CGPoint childP = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; // 寻找到最合适的view return fitView; &#125; &#125; // 循环结束,表示没有比自己更合适的view return self;&#125; pointInside:withEvent:pointInside:withEvent:方法判断点在不在当前view上(方法调用者的坐标系上)如果返回YES, 代表点在方法调用者的坐标系上; 返回NO代表点不在方法调用者的坐标系上, 那么方法调用者也就不能处理事件. 深入浅出iOS事件机制 iOS之事件的传递和响应机制-原理篇","path":"2016/08/27/iOS事件响应链/","date":"08-27","excerpt":""}]}