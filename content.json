{"pages":[{"title":"search","text":"","path":"search/index.html","date":"03-19","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"03-19","excerpt":""}],"posts":[{"title":"路由协议","text":"","path":"2018/04/14/路由协议/","date":"04-14","excerpt":""},{"title":"非著名不专业程序员必备工具","text":"智能搜索工具Alfred 作为一名非著名不专业程序员，搜索几乎占据我们大部分时间。而这款软件可以堪称是利器，无论是谷歌百度还是快捷打开软件都可以大量节省我们时间。推荐 Alfred 插件：1. CodeVar : 可以让英文稀烂的你一样能写出一个标准英文变量名2. Kill Process: 快捷杀死程序 编程语言Api文档 Dash Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 接口调试工具 postman 引用官网一句话： Developers use Postman to build modern software for the API-first world. 代码管理可视化工具 SVN： 使用cornerstone Git: 使用Sourcetree Finder扩展工具 TotalFinder TotalFinder是mac搜索增强工具，具有多标签式浏览、拷贝路径、剪切文件、显示隐藏文件、双窗口模式等功能，让你浏览和搜索文件更加方便 MarkDown笔记编写工具 FaIcon 如果你像我一样比较懒不喜欢记MarkDown语法，那么就可以使用这款MarkDown 工具，内置常用语法标签按钮 邮件应用 Airmail 如果你像我一样喜欢根据个人习惯来定制应用，以求效率最大化的人，Airmail 高度的可定制性一定会让你欣喜若狂。只要你上手体验几分钟，你也会像我一样得出「Airmail 是现在 iOS 上可自定义程度最高的邮件应用」 强大的终端工具 ITerm2 如果你像我一样也喜欢搞些花里胡哨的界面，还可以配合oh-my-zsh插件做一些自定义配色方案 ~~~~最后送给大家两个Mac破解软件的网站大部分破解软件都能搜索到。精品MAC应用分享史蒂芬周的博客","path":"2018/03/20/非著名不专业程序员必备工具/","date":"03-20","excerpt":""},{"title":"iOS优质博客","text":"高质量 iOS 博客推荐","path":"2018/03/18/iOS优质博客/","date":"03-18","excerpt":""},{"title":"runloop","text":"RunLoop的概念RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供一个入口函数执行Event Loop的逻辑.线程执行了这个函数后，就会一直处于这个函数内部“接收消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束（比如传入quit消息）. runloop在iOS开发中的作用是： runloop保持主线程不会被销毁，能保证程序的持续运行.（程序一启动就会开启一个主线程，主线程中的runloop是自动创建并运行的） 处理App中的各种事件(如: touches 触摸事件, NSTimer 定时器事件） 节省CPU资源, 提高程序性能(有事情就做事情, 没事情就休息(其资源释放)). 负责渲染屏幕上的所有UI 获取线程中的runloop苹果不允许直接创建 RunLoop, 它只提供了两个自动获取的函数. Foundation： [NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象 [NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation： CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象 CFRunLoopGetMain(); // 获得主线程的RunLoop对象 iOS提供了两个这样的对象: NSRunLoop 和 CFRunLoopRef. CFRunLoopRef 是在 CoreFoundation 框架内的, 它提供了纯 C 函数的 API, 所有这些 API 都是线程安全的.NSRunLoop 是基于 CFRunLoopRef 的封装, 提供了面向对象的 API, 但是这些 API 不是线程安全的. CFDictionarySetValue(loopsDic, thread, loop)线程与RunLoop之间是一一对应的关系，保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop. RunLoop ModeCFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRe从上图中可以看出一个RunLoop对象中可以包含多个Mode,每个Mode又包含若干个 Source/Timer/Observer.但是每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode.如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响. 如果一个 mode 中一个 item 都没有, 则 RunLoop 会直接退出, 不进入循环. CFRunLoopSourceRefCFRunLoopSourceRef是事件源(输入源), 例如外部的触摸, 点击事件和系统内部进程间的通信等 source0:非基于Port的,用于用户主动触发的事件source1:基于Port的，通过内核和其他线程相互发送消息 CFRunLoopTimerRef是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。它受RunLoop的Mode影响, GCD的定时器不受RunLoop的Mode影响. CFRunLoopObserverRef每个 Observer 都包含了一个回调(函数指针)当 RunLoop 的状态发生变化时, 观察者就能通过回调接受到这个变化. 可以观测的时间点有以下几个: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop （1） kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer （2） kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source （4） kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 （32） kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 (64) kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop (128) kCFRunLoopAllActivities = 0x0FFFFFFU, // 包含上面所有状态&#125;; CFRunLoopModeRef系统默认注册了5个Mode: NSDefaultRunLoopMode: App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态. UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到. NSRunLoopCommonModes: 这是一个占位用的Mode, 不是一种真正的Mode. 这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.应用场景举例: 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作. 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到commonMode 中。那么所有被标记为commonMode的mode（defaultMode和TrackingMode）都会执行该timer。这样你在滑动界面的时候也能够调用timer 运行RunLoop具体的流程 参考资料：深入理解RunLoop","path":"2017/08/07/runloop/","date":"08-07","excerpt":""},{"title":"runtime实践","text":"例题分析[self class]与[super class]1234567891011@implementation Son : Father- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125;return self;&#125;@end 运行结果： 122018-04-15 12:27:36.776910+0800 Runtime[2173:159137] Son2018-04-15 12:27:36.777059+0800 Runtime[2173:159137] Son 当调用[self class]时, 先调用的是 objc_msgSend 函数, 第一个参数是Son这个类的实例, 然后去示例的ISA(Son类)中找 - (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 而 - (Class)class 的实现就是返回self的类别, 故上述输出结果为 Son. 当调用[supe class]时, 先调用的是class_getSuperclass函数, 该函数第一个参数是结构体 objc_super(第一个参数是self, 第二个参数是当前实例变量的super_class, 就是Father类). 然后直接从实例变量所在类的父类(Father)去找- (Class)class 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用, 此时已经和[self class]调用相同了, 故上述输出结果仍然返回 Son. isKindOfClass与isMemberOfClass1234567BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Father class] isKindOfClass:[Father class]];BOOL res4 = [[Father class] isMemberOfClass:[Father class]];NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); 结果： 12018-04-15 13:03:38.053683+0800 Runtime[2262:176716] 1 0 0 0 内部实现： 1234567891011121314151617181920212223242526272829+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj) &#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;- (BOOL)isKindOf:(Class)cls &#123; Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isMemberOf:(Class)cls &#123; return [self class] == cls;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125; res1：[NSObject class]返回NSObject,接着执行 + isKindOfClass, object_getClass((id)self)返回的是NSObject的isa 也就是NSObject 的meta class,所以第一次循环判断不等，第二次tcls = tcls-&gt;superclass也就是NSObject所以相等.结果为YES. res2：[NSObject class]返回NSObject,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO res3：[Father class]返回Father,接着执行 + isKindOfClass, object_getClass((id)self)返回的是Father的isa 也就是Father 的meta class,第二次tcls = tcls-&gt;superclass也就是NSObject的Meta Class,第三次是NSObject的Meta Class的superclass也就是NSObject,第四次是NSObject的superclass 为nil。退出循环，结果为NO. [Father class]返回Father,接着执行+ (BOOL)isMemberOfClass:(Class)cls,结果为NO Category123456789101112131415161718下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface NSObject (Student) + (void)foo; - (void)foo; @end @implementation NSObject (Student) - (void)foo &#123; NSLog(@&quot;IMP: -[NSObject(Student) foo]&quot;); &#125;@end#import &quot;NSObject+Student.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; [NSObject foo]; [[NSObject new] foo]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 结果： 122018-04-16 17:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo]2018-04-16 17:34:33.595243+0800 Runtime[12538:440536] IMP: -[NSObject(Student) foo] 分析：category中新增的方法, 如果是实例方法, 协议以及属性是直接添加到当前类上面, 如果是类方法和协议则会添加到当前类的原类上面去. 所以调用[NSObject foo]时, 由于是类方法, 根据objc_msgSend的相关知识, 会先在NSObject(Class)的isa中也就是NSObject的meta-class中, 去查找foo方法的IMP, 没找到, 然后去NSObject的meta-class的superclass(NSObject)中找, 找到了, 执行foo方法. 调用[[NSObject new] foo]时, 会先在NSObject(Object)的isa中, 也就是NSObject(Class)中找, 找到了, 直接执行, 输出结果. Runtime的常见用法Method SwizzlingMethod Swizzling本质上就是对IMP和SEL进行交换, 当Method Swilzzling代码执行完毕之后互换才起作用, Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式. 我们替换ViewController的viewWillAppear:方法为例, 使用方式如下: 123456789101112131415161718192021222324252627@implementation ViewController (MethodSwizzling)+ (void)load &#123; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; Class class = [self class]; //这里需要注意, 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //我们先把要替换的类添加到category中 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; //class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; //交换IMP, IMP是函数指针, 直接指向方法的内存地址 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@&quot;%@ viewWillAppear&quot;, self);&#125;@end 这里有几点是要注意的: Objective-C在运行时会自动调用类的两个方法+load和+initialize. +load会在类初始加载时调用, +initialize方法是以懒加载的方式被调用的, 只有当你给某个类或它的子类发送消息, 那么这个类的+initialize方法才会被调用. 所以Swizzling要写在+load方法中, 因为写在+initialize方法中, 是有可能永远都不被执行. Swizzling应该只被执行一次, 如果Swizzling的方法被多次执行, 那么就有可能造成Swizzling失效, 所以我们要用dispatch_once来保证只被执行一次. Swizzling在+load中执行时, 不要调用[super load]. 如果是多继承, 并且对同一个方法都进行了Swizzling, 那么调用[super load]以后, 父类的Swizzling就失效了. 在swizzling的过程中, 方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中. 这时不会产生无限循环. 如果我们调用的是[self viewWillAppear:animated], 因为viewWillAppear:被重定向到xxx_viewWillAppear:, 就会产生无限循环. 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身. 我们也可以使用这个来做一些异常保护, 例如数组的越界问题, 我们可以Swizzling数组的objectAtIndex:方法, 在新方法中做一些异常处理, 来抛出一些异常信息, 方便我们定位问题. NSCoding的自动归档和自动解档主要思路是获取成员变量列表, 利用KVC读取和赋值来完成encodeWithCoder和initWithCoder. 123456789101112131415161718192021222324252627282930#import &quot;Student.h&quot;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation Student- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125;&#125;- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; return self;&#125;@end 参考资料： 神经病院 Objective-C Runtime 入院系列 Objective-C Runtime Objective-C Runtime 运行时系列 iOS 如何实现 Aspect Oriented Programming Method Swizzling 和 AOP 实践 刨根问底Objective－C Runtime 深入理解Objective-C：Category Objective-C 消息发送与转发机制原理","path":"2017/07/23/runtime实践/","date":"07-23","excerpt":""},{"title":"iOS中的runtime","text":"Objective-C是C的语言的超集,C是一门静态语言而Objective-C却是一门动态语言,这个动态特性就是由基于Smalltalk消息传递特性的Runtime来提供的.纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 Runtime简介Objective-C在三种层面上与Runtime系统进行交互: 通过 Objective-C 源代码Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码, 在运行时确定对应的数据结构和调用具体哪个方法. 通过 Foundation 框架的 NSObject 类定义的方法NSObject类是遵守NSObject协议的, 在这个协议里面有很多方法是和Runtime相关, 或者直接从Runtime中获取信息的. 通过对 Runtime 库函数的直接调用在这里需要注意一下, 系统本身是默认关闭了Runtime的代码提示的, 我们需要在BuildSettings -&gt; Enable Strict Checking objc_msgSend Calls -&gt;设置为NOObjective-C 的 Runtime 为我们提供了很多运行时状态下跟类与对象相关的函数,具体的可以看Objective-C Runtime Reference. Runtime 基础数据结构Object(对象), Class(类), Meta Class(原类), id. 通过objc_class的定义我们大致可以看出他们之间的关系: 12345678910111213141516171819202122232425typedef struct objc_class *Class; typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123; private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; id在Objective-C中可以代指任意的对象类型，他是一个指向objc_object结构体的指针（typedef struct objc_object *id;这个struct的定义本身就带了一个 , 所以我们在使用其他NSObject类型的实例时需要在前面加上 , 而使用 id 时却不用） 那么什么是 objc_object 呢? Objective-C中的Object(objc_object)在最后会被转换成C的结构体, 而在这个struct中有一个 isa_t 类型的结构体isa, 通过查看 isa_t 我们发现它里面有一个指向它的类别 Class(定义了对象所属的类). 注意: isa 指针不总是指向实例对象所属的类, 不能依靠它来确定类型, 而是应该用 class 方法来确定实例对象的类. 123456789101112struct objc_object &#123; private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor);&#125; 3.那么什么是 Class 呢? Class 其实是一个指向 objc_class 结构体的指针（typedef struct objc_class *Class;） 123456struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; 总结: Class在设计中本身也是一个对象. 而这个Class对象的对应的类, 我们叫它 Meta Class, 它用来表述类对象本身所具备的元数据, 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法. 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 即Class结构体中的 isa 指向的就是它的 Meta Class. 我们可以把Meta Class理解为一个Class对象的Class. 当我们给一个NSObject对象发送消息时(实例方法), 这条消息会在对象所属的类的方法列表里查找. 当我们发送一个消息给一个类时(类方法), 这条消息会在类的Meta Class的方法列表里查找. 下面这个图很好地说明了Object, Class, Meta Class之间的关系. 每个实例(Object)的isa指针都指向该实例所属的类. 每个类(Class)的isa指针都指向为一个该类所属的Meta Class(原类). 每个Meta Class(原类)的isa指针都指向Root Class(Meta)(根原类), 大部分情况是都是NSObject. Root class(meta)的superclass指向Root class(Class), 也就是NSObject, 形成一个回路. Root class(Class)其实就是NSObject, NSObject是没有超类的, 所以Root class(Class)的superclass指向nil. isa_tobjc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体. 因为 isa_t 使用 union 实现, 所以可能表示多种形态, 既可以当成是指针, 也可以存储标志位. 有关 isa_t 联合体的更多内容可以查看Objective-C 引用计数原理. 1234567union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; cache_tcache_t 出现在 objc_class 中, cache_t 中存储了一个 bucket_t 的结构体 _buckets ，和两个unsigned int 的变量 _mask 和 _occupied. _mask 分配用来缓存bucket的总数, _occupied 表明目前实际占用的缓存bucket的个数. bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP. IMP是一个函数指针, 指向了一个方法的具体实现. bucket_t *_buckets其实就是一个散列表, 用来存储Method的链表. Cache 的作用主要是为了优化方法调用的性能. 当对象receiver调用方法message时, 首先根据对象receiver 的 isa 指针查找到它对应的类, 然后在类的 methodLists 中搜索方法, 如果没有找到, 就使用 super_class 指针到父类中的 methodLists 查找, 一旦找到就调用方法. 如果没有找到, 有可能消息转发, 也可能忽略它. 但这样查找方式效率太低, 所以使用Cache来缓存经常调用的方法, 当调用方法时, 优先在Cache查找, 如果没有找到, 再到methodLists查找. 123456789101112131415161718192021222324//cache_t结构struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125; typedef unsigned int uint32_t; typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t; typedef uintptr_t cache_key_t; struct bucket_t &#123; private: cache_key_t _key; IMP _imp;public: inline cache_key_t key() const &#123; return _key; &#125; inline IMP imp() const &#123; return (IMP)_imp; &#125; inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125; inline void setImp(IMP newImp) &#123; _imp = newImp; &#125; void set(cache_key_t newKey, IMP newImp);&#125; class_data_bits_t1234567891011121314151617181920212223242526272829303132333435363738394041424344//class_data_bits_t结构struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125; struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125; struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 上面这张图很好地说明了 class_data_bits_t 的作用. 详见深入解析 ObjC 中方法的结构. 大致说明一下就是, Objc的类的属性, 方法, 以及遵循的协议在obj 2.0的版本之后都放在 class_rw_t 中. class_ro_t 是一个指向常量的指针, 存储来编译器决定了的属性、方法和遵守协议. 在运行时发消息时, 会从 class_data_bits_t 调用 data 方法, 将结果从 class_rw_t 强制转换为 class_ro_t 指针. 最后调用 methodizeClass 方法, 把类里面的属性, 协议, 方法都加载进来. 方法与消息SELSEL 又叫做方法选择器, 是表示一个方法的 selector 的指针, 定义如下: 1typedef struct objc_selector *SEL; OC在编译时，会依据每一个方法的名字，参数序列，生成一个唯一整形标识（Int类型的地址），这个标识就是SEL.不同类的不同方法，只要方法名相同，哪怕参数类型不同，这两个方法的SEL就是一样的.同一个类中就不能存在两个方法名一致，参数不一致，这样编译器就会报错.但不同的类就可以，因为不同类的实例对象执行方法时，是从各自类的方法列表中根据selector去寻找自己对应的IMP. 工程中所有的SEL组合成一个set集合，因此SEL是唯一的.set中的元素都是唯一的，所以SEL也是唯一的，所以我们找一个selector，通过他对应的SEL是最快的方法.SEL实际就是根据方法名Hash过的一个字符串（这也解释了上面相同方法名编译为什么报错的原因），字符串的比较只需比较地址就可以了，速度非常快.本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度 我们可以在运行时添加和获取selector，也可以通过下面几种方法来获取SEL: 1231. sel_registerName函数2. Objective-C编译器提供的@selector()3. NSSelectorFromString()方法 IMPIMP实际上是一个函数指针，指向方法实现的地址，定义如下 1id (*IMP)(id, SEL,...) 该函数的第一个参数是self的指针，如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针.第二个参数是方法选择器，后面是方法的参数列表. 每个方法对应唯一的SEL，我们通过SEL就是为了查找方法的最终实现IMP，而IMP这个函数指针指向了最终的方法实现，取得IMP后，我们就获得了执行这个方法代码的入口点.通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现.这样就省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些. 通过一组id和SEL参数就能确定唯一的方法实现地址，而一个确定的方法也只有唯一的一组id和SEL参数 MethodMethod用于表示类定义中的方法，定义如下： 12345678910111213struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 我们可以看到，该结构体包含name(方法名，本质是IMP)，types(方法类型，本质是个char指针，存储方法的参数类型和返回值)，imp（方法指向，本质是个IMP，也可以说是函数指针）.该结构体实际上相当于在SEL和IMP之间做了一个映射，让我们可以通过SEL快速找到IMP. 成员变量与属性IvarIvar用来表示实例变量，其实际是一个指向objc_ivar结构体的指针，定义如下： 12345678910111213typedef struct objc_ivar *Ivar;struct ivar_t &#123; int32_t *offset;//表示基地址偏移字节 const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; 我们对ivar的访问就可以通过 对象地址 + lvar偏移字节的方法来访问，但是如果增加了父类的lvar，那怎么办，OC使用Non Fragile Ivars机制，Runtime会进行检测来调整类中新增的ivar的偏移量，这样我们就可以通过 对象地址 + 基类大小 + lvar偏移字节的方法计算出对应的ivar地址，并访问到相应的ivar，而不用重新编译子类 我们无法通过 -&gt;函数来修改私有属性，但是我们可以通过对象地址 + lvar偏移量来访问地址，获取指针后直接修改 属性实际就是lvar加上系统自动为我们生成的get和set方法 objc_property_t@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针: 1typedef struct property_t *objc_property_t; 需要注意的是，与 class_copyIvarList 函数不同, 使用 class_copyPropertyList 函数只能获取类的属性, 而不包含成员变量, 但此时获取的属性名是不带下划线的. 更多姿势可以看这里. protocol_t12345678910111213141516struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; ... 省略一些封装的便捷 get 方法&#125; CategoryCategory(分类), 他为现有的类提供了扩展, 它是 category_t 结构体的指针.详细查看深入理解Objective-C：Category 123456789typedef struct category_t *Category;typedef struct category_t &#123; const char *name;//类的名字 classref_t cls;//类 struct method_list_t *instanceMethods;//category中所有给类添加的实例方法的列表 struct method_list_t *classMethods;//给所有类添加类方法的列表 struct protocol_list_t *protocols;//所有协议的列表 struct property_list_t *instanceProperties;//category中添加的所有属性的列表&#125; category_t; 从category的定义可以看出我们可以添加实例方法，类方法，甚至可以实现协议，添加属性，但是无法添加实例变量 在App的启动过程中，会在_read_images函数间接调用到attachCategories函数，完成向类中添加Category的工作，向class_rw_t中的method_array_t，property_array_t，protocol_array_t 数组中分别添加method_list_t，property_list_t，protocol_list_t指针.把category的实例方法, 协议以及属性添加到类上, 把category的类方法和协议添加到类的metaclass上. 我们需要注意的是： category不会覆盖原类中的方法，而是两个都存在，但是category的在前面，按照方法列表来找，找到category的之后, 就不再往下找了, 造成被覆盖的假象. 附加category的类的工作会先于+load方法的执行. +load的执行顺序是先类, 后category, 而category的+load执行顺序是根据编译顺序(Compile Sources中的顺序)决定的. 消息查找与转发Objective-C中任何方法的调用, 编译器都会将[receiver message]转化为一个消息函数的调用, 即objc_msgSend, 消息直到运行时才绑定到方法的实现上. objc_msgSend 的定义如下: 1objc_msgSend(receiver, selector, arg1, arg2, ...) 消息的查找和动态解析 判断 selector 是不是需要被忽略的垃圾回收用到的方法, 是的话就忽略, 不是的话继续下一步操作. 判断target是不是nil, 如果这里有相应的nil的处理函数, 就跳转到相应的函数中. 如果没有处理nil的函数, 就自动清理现场并返回. 这一点就是为何在OC中给nil发送消息不会崩溃的原因. 查找当前类的缓存, 如果命中缓存获取到了IMP就将IMP返回, 如果没有继续下一步操作. 在当前类的方法列表中查找(根据 selector 查找到 Method 后, 获取 Method 中的 IMP), 对已经排序的列表使用二分法查找, 未排序的列表则是线性遍历. 如果找到把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在继承层级中递归向父类(一直到 NSObject 为止)中查找, 情况跟上一步类似, 也是先查找缓存, 缓存没中就查找方法列表, 查到后就终止递归查询, 把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作. 在消息查找阶段, 如果没找到IMP(也就是接收到未知的消息), 会进入动态方法解析阶段, 首先会调用所属类的+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)方法. 前提是我们必须自己实现该方法, 并且添加到类里面. 1234567891011void functionForMethod1(id self, SEL _cmd) &#123; NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125; + (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123; class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125; 此时如果既没有没查找到 IMP, 动态方法解析也不奏效, 那么就进入了下一个阶段-消息转发阶段. 消息的转发上面主要是消息的查找阶段主要完成的是通过select()快速查找IMP的过程, 接下来才是消息的转发阶段, 到了转发阶段, 会调用到了转发阶段, 会调用id _objc_msgForward(id self, SEL _cmd,…)方法. 在执行_objc_msgForward之后会调用 __objc_forward_handler函数. 它的实现大致如下: 12345678// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel) &#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self);&#125; 当我们给一个对象发送一个没有实现的方法的时候, 如果其父类也没有这个方法, 则会崩溃, 报错信息类似于这样: unrecognized selector sent to instance, 然后接着会跳出一些堆栈信息. 这些信息就是从这里而来. 如果上面的查找和解析都失败的话, 消息就会无法处理, 这是Runtime会调用以下方法: 1- (id)forwardingTargetForSelector:(SEL)aSelector 我们可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来把消息的接受者换成一个可以处理该消息的实例对象或者类对象. 示例如下: 12345678910111213- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(Method:))&#123; return otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@&quot;Class name&quot;); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果一个对象实现了这个方法, 并返回一个非nil的结果, 则这个对象会作为消息的新接收者, 且消息会被分发到这个对象.当然这个对象不能是self自身, 否则就是出现无限循环.如果我们没有指定相应的对象来处理aSelector, 则应该调用父类的实现来返回结果. 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上, 但这一步无法对消息进行处理, 如操作消息的参数和返回值. 如果在上一步还不能处理未知消息, 则唯一能做的就是启用完整的消息转发机制了. 运行时系统会给消息接收者最后一次机会将消息转发给其它对象. 我们首先要通过, 指定方法签名, 若返回nil, 则表示不处理. 123456- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123; return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector: aSelector];&#125; 若返回方法签名, 则会进入下一步调用. 12345678- (void)forwardInvovation:(NSInvocation)anInvocation &#123; if ([someOtherObject respondsToSelector: [anInvocation selector]]) &#123; [anInvocation invokeWithTarget:someOtherObject]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 该方法对象会创建一个表示消息的NSInvocation对象,把与尚未处理的消息有关的全部细节都封装在anInvocation中, 包括selector, 目标(target)和参数. 我们可以在forwardInvocation方法中选择将消息转发给其它对象. 我们可以通过anInvocation对象做很多处理, 比如修改实现方法, 修改响应对象等. 这个方法的主要作用是定位可以响应封装在anInvocation中的消息的对象(这个对象不需要能处理所有未知消息). 使用anInvocation作为参数, 将消息发送到选中的对象. anInvocation将会保留调用结果, 运行时系统会提取这一结果并将其发送到消息的原始发送者. 在这个方法中我们也可以实现一些更复杂的功能, 我们可以对消息的内容进行修改, 比如追回一个参数等, 然后再去触发消息. 另外, 若发现某个消息不应由本类处理, 则应调用父类的同名方法, 以便继承体系中的每个类都有机会处理此调用请求. 上面两个补救措施做完后, 若发现某调用不应由本类处理, 则会调用超类的同名方法. 如此, 继承体系中的每个类都有机会处理该方法调用的请求, 一直到NSObject根类. 如果到NSObject也不能处理该条消息, 那么就是再无挽救措施了, 只能抛出”doesNotRecognizeSelector”异常.","path":"2017/07/18/runtime/","date":"07-18","excerpt":""},{"title":"UIView介绍","text":"生命周期创建View时： initWithFrame: initWithFrame进行初始化时, 当rect的值不为CGRectZero时会触发layoutSubviews. init初始化不会触发layoutSubviews. willMoveToSuperview: 当视图即将加入父视图时 / 当视图即将从父视图移除时调用 didMoveToSuperview: 当试图加入父视图时 / 当视图从父视图移除时调用 willMoveToWindow: 当视图即将加入父视图时 / 当视图即将从父视图移除时调用 didMoveToWindow: 当试图加入父视图时 / 当视图从父视图移除时调用 layoutSubviews: 在子视图布局变动时会多次调用 当View销毁时: willMoveToWindow didMoveToWindow willMoveToSuperview didMoveToSuperview removeFromSuperview dealloc 如果View中有子View的话, 创建时除了上面的顺序之外, 还会调用: layoutSubviews, 这是因为子视图的布局变动, 所以会触发. didAddSubview drawRect 移除时, 除了上面的顺序之外, 还会调用willRemoveSubview, 是在dealloc后面执行的. 如果有多个子视图, willRemoveSubview会循环执行, 直到移除所有子视图. UIView和CALayer UIView继承于UIResponder,可以响应触摸事件. CALayer继承于NSObject,不能响应触摸事件. UIView主要是对显示内容的管理, CALayer主要侧重显示内容的绘制.所以访问UIView与绘图相关属性（frame,bounds）等实际上内部都是在访问它所包含的CALayer的相关属性.UIView的创建实际上是一系列CALayer创建的过程. UIView有个重要属性layer. 可以返回它的主CALayer实例. 所有从UIView继承来的对象都继承了这个属性. 这意味着你可以在所有的UIVIew子类上增加动画, 旋转, 缩放等CALayer支持的操作. UIView的layerClass方法, 可以返回主layer所使用的类, UIView的子类可以通过重载这个方法, 来让UIView使用不同的CALayer来显示. 代码示例： 123- (class)layerClass &#123; return ([CAEAGLLayer class]);&#125; UIView的主CALayer是类似于subviews的树形结构, 我们可以通过给主layer添加子layer来完成特殊的绘制效果.在view上添加一个黑色透明layer层的示例代码: 123grayCover = [[CALayer alloc] init];grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];[self.layer addSubLayer:grayCover]; UIView的内部, 有三个layer tree: 1.逻辑树, 这里是代码可以操纵的. 2.动画树, 是一个中间层, 系统就在这一层上通过逻辑树来更改属性, 进行各种渲染操作. 3.显示树, 其内容就是当前正被显示在屏幕上得内容. UIView实际上是CALayer的CALayerDelegate, 通过实现一系列的代理方法来显示CALayer绘制的内容. 在做 iOS 动画的时候, 修改非RootLayer的属性(譬如位置, 背景色等)会默认产生隐式动画, 而修改UIView则不会. layer可以设置圆角显示(cornerRadius), 也可以设置阴影(shadowColor). 但是如果layer树中某个layer设置了圆角, 树种所有layer的阴影效果都将不显示了. 因此若是要有圆角又要阴影, 变通方法只能做两个重叠的UIView, 一个的layer显示圆角, 一个layer显示阴影. UIView 是UIKit框架下的(只能iOS使用). CALayer 是QuartzCore的(iOS 和macOS通用). QuartzCore的渲染能力. 使二维图像可以被自由操纵, 就好像是三维的. 图像可以在一个三维坐标系中以任意角度被旋转, 缩放和倾斜. CATransform3D的一套方法提供了一些魔术般的变换效果.参考链接：详解CALayer 和 UIView的区别和联系,UIView和CALayer的区别 drawRect该方法默认没有任何操作代码,如果视图中包含我们用UIKit或者Core Graphics绘制的内容, 我们需要重写该方法. 当视图第一次出现, 或者是改变约束条件让视图的全部或者一部分在屏幕上发生变化时, 系统都会调用UIView类的drawRect方法. 然后我们在此方法中能过获取到当前图形上下文, 实现我们的绘制内容, 最后系统会在合适的时机自动调用此方法. drawRect一般调用是在UIView的layoutSubviews方法执行后.但是, 在我们的视图全部初始化后,如果视图又发生了改变, 此时视图就需要重绘, 但是系统不会再帮我们自动调用drewRect方法. 这个时候就需要我们手动调用UIView类的 setNeedsDisplay或setNeedsDisplayInRect方法. 这两个方法是用来告诉系统, 我们的视图有了更新需要去重绘. 相当于是给系统做了标记, 在系统 runloop 的下一个周期自动调用drawRect方法. 使用中要注意的地方: 不要直接调用 drawRect 方法,如果强行调用此方法也是无效果的.苹果要求我们调用 UIView 类的 setNeedsDisplay 方法,则程序会自动调用 drawRect 方法进行重绘. 因为在绘制时要拿到图形上下文,如果在 UIView 初始化时没有设置 rect 大小, drawRect 方法不会被调用. 调用 sizeThatFits 后, 控件 frame 改变, UIView 的 layoutSubviews 被调用, 然后再调用 drawRect 方法. 所以可以先调用 sizeToFit 计算出size. 然后系统自动调用 drawRect 方法. 通过设置 contentMode 属性值为 UIViewContentModeRedraw.那么将在每次设置或更改 bounds 的时候自动调用 drawRect. 若要实时画图, 如果使用 gestureRecognizer 来刷新屏幕, 需要判断并转化 point 的坐标; 使用 touchbegan 等方法, 只需调用 setNeedsDisplay 实时刷新屏幕. 参考资料：使用drawRect:实现绘制画板功能的内存优化 sizeToFit, sizeThatFitssizeToFit：当我们想要resize当前View以便获取他合适的大小时, 我们需要调用该方法. 尤其是UIKit的View视图是根据内部需要进行尺寸调整时. 在某些情况下, 如果当前View没有父视图, 他会根据屏幕的bounds来resize自身大小. 如果你想让一个View根据父视图来调整大小, 必须将该View添加到父视图中.一般情况下, 我们不需要重写该方法, 如果你想改变当前View的default size, 我们通过重写sizeThatFits:来实现. 在sizeThatFits:方法中进行必要的计算, 返回结果, 然后改变他的大小. sizeThatFits：该方法要求View计算并返回最适合指定大小的大小. 传入的参数就是View需要最合适的大小, 返回值是根据传入的大小, 计算得到的一个最适合receiver子视图的尺寸.该方法默认返回视图的现有大小, 子类能够通过重写该方法获得一个基于该子类所有子视图的期望布局的自定义大小. 调用sizeThatFits:并不改变view的size, 它只是让view根据已有content和给定size计算出最合适的view.size. sizeToFit会自动调用sizeThatFits方法 sizeToFit不应该在子类中被重写, 应该重写sizeThatFits sizeThatFits传入的参数是receiver当前的size, 返回一个适合subviews的size sizeToFit可以被手动直接调用 sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己 调用 sizeToFit() 会去自动调用 sizeThatFits(_ size: CGSize) 方法 sizeThatFits 不会改变 receiver 的 size, 调用 sizeToFit() 会改变 receiver 的 size. 此处的receiver一般是方法的调用者 系统触发layoutSubviews的条件 父视图使用init方法完成初始化时不会触发layoutSubviews 父视图用initWithFrame完成初始化并且当frame参数为CGRectZero时不会触发layoutSubviews. 当frame参数不为CGRectZero时则会触发layoutSubviews 父视图setFrame的时候会触发layoutSubviews, 当然frame前后值得发生变化 父视图addSubview添加子视图时会触发其内部的layoutSubviews 子视图从父视图上removeFromSuperView的时候会触发其内部的layoutSubviews 滚动ScrollView的时候会触发layoutSubviews 旋转屏幕的时候会触发layoutSubviews 系统触发drawRect:的条件 如果在UIView初始化时没有设置rect大小, 将直接导致drawRect不被自动调用. drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的. 所以不用担心一进入到控制器中, 这些View的drawRect就开始画了. 这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值). 该方法在调用sizeToFit后被调用, 所以可以先调用sizeToFit计算出size, 然后系统自动调用drawRect:方法. 通过设置contentMode属性值为UIViewContentModeRedraw. 那么将在每次设置或更改frame的时候自动调用drawRect:. 直接调用setNeedsDisplay或者setNeedsDisplayInRect:触发drawRect:. 但是有个前提条件是rect不能为CGRectZero. 以上1, 2推荐; 而3, 4不提倡.","path":"2017/07/17/UIView介绍/","date":"07-17","excerpt":""},{"title":"UIViewController介绍","text":"生命周期 initWithCoder: 或 initWithNibName:bundle:, 首先从归档文件中加载UIViewController对象. 非StoryBoard创建调用initWithNibName:bundle:, 如果使用StoryBoard进行视图管理, 从nib中加载对象实例时, 程序不会直接初始化一个UIViewController, StoryBoard会自动初始化或在segue被触发时自动初始化initWithCoder:. awakeFromNib, 从xib或者storyboard加载完毕就会调用. loadView, 每次访问UIViewController的view(比如controller.view, self.view)而且view为nil, loadView方法就会被调用. loadView方法是用来负责创建UIViewController的view. 如果在初始化UIViewController指定了xib文件名, 就会根据传入的xib文件名加载对应的xib文件, 如果没有明显地传xib文件名, 就会加载跟UIViewController同名的xib文件. 如果没有找到相关联的xib文件, 就会创建一个空白的UIView, 然后赋值给UIViewController的view属性. 苹果设计这个方法就是给我们自定义UIViewController的view用的, 我们直接在该方法中指定UIViewController的View. viewDidLoad, 无论你是通过xib文件还是重写loadView方法创建UIViewController的view, 在view创建完毕后, 最终都会调用viewDidLoad方法. 在这里视图层次已经加载到内存中. 通常, 我们对于各种初始化数据的载入, 初始设定, 修改约束, 移除视图等很多操作都可以这个方法中实现. viewWillAppear:, 系统在载入所有的数据后, 将会在屏幕上显示视图, 这时会先调用这个方法, 通常我们会在这个方法对即将显示的视图做进一步的设置. viewWillLayoutSubviews, view 即将布局其Subviews. 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化), 要调整Subviews的位置, 在调整之前要做的工作可以放在该方法中实现. viewDidLayoutSubviews, view已经布局其Subviews, 这里可以放置调整完成之后需要做的工作. viewDidAppear:, 在view被添加到视图层级中以及多视图上下级视图切换时调用这个方法, 可以对正在显示的视图做进一步的设置. viewWillDisappear:, 当前视图在即将被移除, 或被覆盖时, 会调用该方法. 此时还没有调用removeFromSuperview. viewDidDisappear:, view已经消失或被覆盖, 此时已经调用removeFromSuperView. dealloc, UIViewController被销毁时调用, 此次需要对你在init和viewDidLoad中创建的对象进行释放. didReceiveMemoryWarning, 内存不够时, 系统会自动调用这个方法. 默认实现是如果当前UIViewController的view不在应用程序的视图层次结构(View Hierarchy)中, 即view的superview为nil的时候, 就会将view释放, 并且调用viewDidUnload方法. viewDidUnload, 收到内存警告时, 如果当前UIViewController的View的superView为nil时, 就会将View释放, 并且调用viewDidUnload. edgesForExtendedLayout, translucent, extendedLayoutIncludesOpaqueBars, automaticallyAdjustsScrollViewInsets edgesForExtendedLayout:iOS7以后 UIViewController 开始使用全屏布局，而且是默认的属性。通常涉及到布局，就离不开这个属性 edgesForExtendedLayout，它是一个类型为UIExtendedEdge的属性，指定UIViewController上的根视图self.view边缘要延伸的方向。由于iOS7鼓励全屏布局，所以它的默认值是UIRectEdgeAll，四周边缘均延伸，就是说，如果即使视图中上有UINavigationBar，下有UITabBar，那么视图仍会延伸覆盖到四周的区域。 12345678910typedef NS_OPTIONS(NSUInteger, UIRectEdge) &#123; UIRectEdgeNone = 0, UIRectEdgeTop = 1 &lt;&lt; 0, UIRectEdgeLeft = 1 &lt;&lt; 1, UIRectEdgeBottom = 1 &lt;&lt; 2, UIRectEdgeRight = 1 &lt;&lt; 3, UIRectEdgeAl = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight &#125; NS_ENUM_AVAILABLE_IOS(7_0); 设置为 UIRectEdgeNone就是不会延伸至UINavigationBar和UITabBar translucent:这个是self.navigationController.navigationBar的属性，设置导航条UINavigationBar是否半透明.默认是YES，也就是半透明. extendedLayoutIncludesOpaqueBars:不透明的条下是否可以扩展.默认为NO，也就是不可以扩展。当translucent设置为NO，即导航栏UINavigationBar不透明的时候，默认不能扩展(空出导航栏部分). automaticallyAdjustsScrollViewInsets: 自动校准滚动视图的嵌入视图,默认YES.automaticallyAdjustsScrollViewInsets根据按所在界面的status bar，navigationbar，与tabbar的高度，自动调整scrollview的 inset,设置为no，不让viewController调整，这种对于一个页面内有多个scrollView或者其子类十分有必要，我们自己修改布局即可. addchildviewcontrolleraddChildViewController是一个从iOS5开始支持的api接口，相关的一系列的接口是用来处理viewcontroller中嵌套显示其他viewcontroller的场景的。这样做的好处是: 对页面中的逻辑更加分明了。相应的View对应相应的ViewController. 当某个子View没有显示时，将不会被Load，减少了内存的使用. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制. 12345678910111213141516171819202122232425262728293031//在parent view controller 中添加 child view controller FirstViewController *firstViewController=[[FirstViewController alloc] initWithNibName:@&quot;FirstViewController&quot; bundle:nil];[self addChildViewController:firstViewController];SecondViewController *secondViewController=[[SecondViewController alloc] initWithNibName:@&quot;SecondViewController&quot; bundle:nil];[self addChildViewController:secondViewController];ThirdViewController *thirdViewController=[[ThirdViewController alloc] initWithNibName:@&quot;ThirdViewController&quot; bundle:nil];[self addChildViewController:thirdViewController];[self.view addSubview:thirdViewController.view]; // addChildViewController会调用[child willMoveToParentViewController:self] ，但是不会调用didMoveToParentViewController，所以需要xian调用[thirdViewController didMoveToParentViewController:self];currentViewController=thirdViewController;///////////////////////////////// * fromViewController 当前显示在父视图控制器中的子视图控制器 * toViewController 将要显示的姿势图控制器 * duration 动画时间(这个属性,old friend 了 O(∩_∩)O) * options 动画效果(渐变,从下往上等等,具体查看API) * animations 转换过程中得动画 * completion 转换完成 *///切换child view controller[self transitionFromViewController:currentViewController toViewController:firstViewController duration:4 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^&#123;&#125; completion:^(BOOL finished) &#123; //......&#125;];currentViewController=firstViewController; //移除child view controller// removeFromParentViewController在移除child前不会调用[self willMoveToParentViewController:nil] ，所以需要显示调用[currentViewController willMoveToParentViewController:nil];[currentViewController removeFromSuperview];[currentViewController removeFromParentViewController];","path":"2017/07/15/UIViewController介绍/","date":"07-15","excerpt":""},{"title":"UICollectionView自定义布局","text":"当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就可以考虑自定义layout。 【必须】定制UICollectionViewLayout必须覆盖的方法123- (void)prepareLayout;- (CGSize)collectionViewContentSize;- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; prepareLayout是专门用来准备布局的，在prepareLayout方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。此方法在布局之前会调用一次，之后只有在调用invalidateLayout,shouldInvalidateLayoutForBoundsChange:返回YES和UICollectionView刷新的时候才会调用. collectionViewContentSize返回内容尺寸给UICollectionView.这个方法返回的尺寸是给UICollectionView这个继承于UIScrollView的视图作为contenSize,不是UICollectionView的视图尺寸.这个方法会多次调用，所以最好是在prepareLayout里就计算好。 layoutAttributesForElementsInRect方法返回一组UICollectionViewLayoutAttributes类对象.它代表着在这个指定的区域中，我们需要显示cell,Supplementary View 和 Decoration View中哪些视图，而这些视图的属性则保存UICollectionViewLayoutAttributes中.此方法会多次调用，为了更好的性能，在这个方法当中，我们使用的UICollectionViewLayoutAttributes最好是在prepareLayout已经布局好的信息。 【可选】交互定制方法12- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; shouldInvalidateLayoutForBoundsChange:当布局的边界发送改变的时候，会询问该方法是否重新布局.一旦重新刷新布局，就会按顺序调用下面的方法: prepareLayout,layoutAttributesForElementsInRect. targetContentOffsetForProposedContentOffset返回值决定collectionView在停止滚动的时候最终的偏移量contentOffset（常见的卡片布局会使用到） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)prepareLayout&#123; [super prepareLayout]; NSMutableArray *layoutInfoArr = [NSMutableArray array]; NSInteger maxNumberOfItems = 0; //获取布局信息 NSInteger numberOfSections = [self.collectionView numberOfSections]; for (NSInteger section = 0; section &lt; numberOfSections; section++)&#123; NSInteger numberOfItems = [self.collectionView numberOfItemsInSection:section]; NSMutableArray *subArr = [NSMutableArray arrayWithCapacity:numberOfItems]; for (NSInteger item = 0; item &lt; numberOfItems; item++)&#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section]; UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:indexPath]; [subArr addObject:attributes]; &#125; if(maxNumberOfItems &lt; numberOfItems)&#123; maxNumberOfItems = numberOfItems; &#125; //添加到二维数组 [layoutInfoArr addObject:[subArr copy]]; &#125; //存储布局信息 self.layoutInfoArr = [layoutInfoArr copy]; //保存内容尺寸 self.contentSize = CGSizeMake(maxNumberOfItems*(self.itemSize.width+self.interitemSpacing)+self.interitemSpacing, numberOfSections*(self.itemSize.height+self.lineSpacing)+self.lineSpacing);&#125;//itemSize是cell的大小，interitemSpacing是cell与cell之间的间距，lineSpacing是行距。- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //每一组cell为一行 attributes.frame = CGRectMake((self.itemSize.width+self.interitemSpacing)*indexPath.row+self.interitemSpacing, (self.itemSize.height+self.lineSpacing)*indexPath.section+self.lineSpacing, self.itemSize.width, self.itemSize.height); return attributes;&#125;- (CGSize)collectionViewContentSize&#123; return self.contentSize;&#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray *layoutAttributesArr = [NSMutableArray array]; [self.layoutInfoArr enumerateObjectsUsingBlock:^(NSArray *array, NSUInteger i, BOOL * _Nonnull stop) &#123; [array enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if(CGRectIntersectsRect(obj.frame, rect)) &#123; [layoutAttributesArr addObject:obj]; &#125; &#125;]; &#125;]; return layoutAttributesArr;&#125;","path":"2017/06/16/UICollectionView自定义布局/","date":"06-16","excerpt":""},{"title":"Cocoapods","text":"Cocoapods概念Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. Cocoapods的实现原理cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一Podfile. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。 Podfile source: spec的地址 platform: 指定构建静态库的平台 target: 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项 pod: 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的 执行完pod install 命令之后，可以发现工程里面多了三个文件, 一个XXX.xcworkspace文件, 一个Podfile.lock文件, 还有一个Pods文件夹. xcworkspace：管理新生成的Project和原本的Project Podfile.lock：记录各个Pod的版本号和之前的依赖关系 Pods： 新生成库的源代码 创建一个Spec RepoSpec Repo是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的: ├── Specs└── [SPEC_NAME]└── [VERSION]└── [SPEC_NAME].podspec如果你要创建私有Pod, 那么你的Spec Repo的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]来把远端的仓库clone到本地. 注意, 这里[Spec Repo的仓库名]不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交PodSpec文件时用到. 创建Pod工程文件我们在你需要创建Pod的目录下使用pod lib create [Pod名称]来创建对应的Pod模板. 实际上该命令行隐藏了默认参数, 参数补全后应该是pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git. 接下来会问你四个问题: What language do you want to use?? [ Swift / ObjC ]. 使用什么语言 Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架 Would you like to do view based testing? [ Yes / No ]. 是否基于View测试 What is your class prefix?. 类的前缀根据自己的实际需要来选择后, 就会自动执行Pod install命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:MyLib├── .travis.yml├── _Pods.xcproject├── Example│ ├── MyLib│ ├── MyLib.xcodeproj│ ├── MyLib.xcworkspace│ ├── Podfile│ ├── Podfile.lock│ ├── Pods│ └── Tests├── LICENSE├── MyLib.podspec├── Pod│ ├── Assets│ └── Classes│ └── RemoveMe.[swift/m]└── README.md接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库: 1234$ git add .$ git commit -s -m “Initial Commit of Library”$ git remote add origin [Pod的远端地址] #添加远端仓库$ git push origin master #提交到远端仓库 编辑Pod文件Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是Assets, 一个是Classes. Assets文件主要用来存放资源文件, 例如图片资源和XIB文件. Classes则存放主要的功能代码, 类.在这里需要注意两个地方: 当我们要使用Pod中的资源时, 以图片为例, 我们通过[UIImage imageWithName:@&quot;xxx.png&quot;]是取不到Pod中的图片的, 因为imageWithName:方法默认是从mainBundle中来取的, 而Pod不属于mainBundle的范畴, 我们需要先根据class来拿到当前类所在的bundle, 再取该Bundle中的资源. 每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行pod update命令来重新建立索引. 编辑Podspec文件初始时的Podspec文件包含了各种信息, 详细的说明我们可以看官方文档,这里贴上最基础的用法代码 123456789101112131415161718192021222324252627282930313233Pod::Spec.new do |s|s.name = ‘LevinPods’#Pod的版本s.version = ‘0.1.0’s.summary = ‘你在搜索时会呈现’s.description = &lt;&lt;-DESC这里是关于你Pod功能的描述DESCs.homepage = ‘https://github.com/HChong3210/HCPods‘s.license = &#123; :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ &#125;s.author = &#123; ‘LevinLuo’ =&gt; ‘786325209@qq.com’ &#125;#Pod的远端仓库地址s.source = &#123; :git =&gt; ‘https://github.com/xxx/LevinPods.git‘, :tag =&gt; s.version.to_s &#125;#Pod支持的最低版本s.ios.deployment_target = ‘8.0’#Pod源文件的位置s.source_files = ‘LevinPods/Classes/*/‘#Pod中资源文件的位置s.resource_bundles = &#123;‘DFCForms’ =&gt; [‘LevinPods/Assets/*.&#123;png,xib,plist&#125;’]&#125;#对外公开的类s.public_header_files = ‘DFCForms/Classes/*/.h’#Pod中用到的第三方库s.frameworks = ‘UIKit’s.dependency ‘AFNetworking’, ‘~&gt; 2.3’s.dependency ‘SDWebImage’end 提交Pod文件Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, 注意, 这里的Tag必须和Podspec文件中的Pod版本号一致 , 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码: 12345git statusgit add .git tag -m ‘备注’ 版本号git commit -s -m ‘备注’git push origin master —tags 提交Podspec文件提交完Pod文件后, 我们只用把Podspec文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了.在提交之前我们可以在根目录下使用pod lib lint命令来验证是否编译通过. 也可以直接提交pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose subspec的使用有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在Podspec文件中这样设置: 1234567s.subspec ‘[子Pod名称]’ do |pod1|pod1.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘ends.subspec ‘[子Pod名称]’ do |pod2|pod2.source_files = ‘SCCQRCode/Classes/[子文件夹名]/*/‘end 我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency. 我们在外面引用该Pod的时候就可以使用pod [Pod/子Pod]的方式来只引用一个子Pod. 常见Pod依赖的几种写法pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]pod ‘QueryKit/Attribute’pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’pod ‘AFNetworking’, :git =&gt; ‘https://github.com/gowalla/AFNetworking.git‘pod ‘JSONKit’, :podspec =&gt; ‘https://example.com/JSONKit.podspec‘ 参考资料 Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验 细聊Cocoapods与Xcode工程配置 使用Cocoapods创建私有podspec CocoaPods 都做了什么？ 使用私有Cocoapods仓库中引用.a库 深入理解CocoaPods","path":"2017/06/03/Cocoapods/","date":"06-03","excerpt":""},{"title":"iOS项目工程概念","text":"Xcode Workspaceworkspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件. 一个workspace可以管理多个Project,pod install的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project. Xcode Projectproject就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。 Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。 project包含了以下信息： 源文件 代码的头文件和实现文件 静态库，动态库 资源文件(如图片，文本，xml，plist等) 界面资源文件(xib， storyboard等) 在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹) project的编译级别配置文件如(debug， release) target 运行环境如：debug，test project可以单独存在，或者存在于一个workspace中. Xcode Targettarget 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product. 这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效. target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。 指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置. Scheme一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme. scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 Build Settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准 一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。 除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.关于继承关系，The Unofficial Guide to xcconfig files这里也有详细的说明，强烈建议阅读。动态环境配置就是使用自定义的 build settings 来实现的. 参考资料: Xcode使用xcconfig文件配置环境 Apple官方文档 Xcode中的Scheme和Build Configuration Xcode workSpace 多个project联编","path":"2017/05/11/iOS项目工程概念/","date":"05-11","excerpt":""},{"title":"Instruments使用","text":"Instruments 是 Xcode 提供我们调试App性能的分析工具 打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面 Core AnimationCore Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿. Color Blended Layers，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。 Color Hits Green and Misses Red，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。 Color Copied Images，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。 Color Non-Standard Surface Formats, 不标准的表面颜色格式. Color Immediately，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。 Color Misaligned Images，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。 Color Offscreen-Rendered Yellow，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。 Color Compositing Fast Path Blue，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。 Flash Updated Regions，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。 Leaks关于内存方面的监控, 有Leaks用来检测内存泄漏, Zombies用来检测僵尸对象. 关于内存泄漏常见的几种情况, 可以参考这里 Time Profiler这个主要是用来统计各个方法消耗的时间.如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的. Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Time Profiler无法定位到代码 Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File Profile要在debug模式下运行, BuildConfiguration要选择debug. 参考资料 iOS 性能优化：Instruments 工具的救命三招 Instruments性能优化-Core Animation 使用 Instruments 做 iOS 程序性能调试 关于内存泄漏，还有哪些是你不知道的？ 使用Instruments定位iOS应用的Memory Leaks instrument Time Profiler总结","path":"2017/04/28/Instruments使用/","date":"04-28","excerpt":""},{"title":"iOS内存分配","text":"计算机系统中，应用程序的数据都保存在内存中，不同的数据类型保存的区域也不同。 RAM和ROM RAM：运行时内存，程序在运行过程中的使用的内存，不能掉电存储 ROM：存储形内存（内存卡），RAM的速度和价格都高于ROM App程序启动，系统会把存储在ROM中的程序拷贝到RAM中，然后从内存里面执行代码 内存分区堆区：Heap堆区由程序员来分配(oc: alloc swift: init)和释放 ARC下的内存管理由编译器自动添加retain, release, autorelease等关键字 堆区的地址由低到高分配 不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理) 堆空间的分配总是动态的 需要程序猿进行分配和释放 栈区 Stack栈区是由编译器自动分配和释放的，用来存放局部变量，函数的参数值，函数跳转地址等iPhone栈区大小是512K 不需要我们管理栈区变量的内存 栈区地址从高到低分配 先进后出栈空间有静态分配和动态分配两种 静态分配是由编译器完成，比如自动变量auto的分配. 动态分配由alloca函数完成. 栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配. 全局区 static全局区也叫做静态区，全局变量和静态变量在内存中是存放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和静态变量放在相邻的宁一块区域，程序结束后由系统释放 常量区存放字符串常量，程序结束后由系统自己释放 代码区代码区用于存放函数的二进制代码，App的代码，程序结束后由系统释放 内存分区地址如图所示：代码区的地址最低，栈区最高，但区与区之间的地址不连续 栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便. 系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容). 变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回. 当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃. 申请内存后系统的响应 栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小. 堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去. 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.堆获得的空间比较灵活, 也比较大.","path":"2017/04/14/iOS内存分配/","date":"04-14","excerpt":""}]}