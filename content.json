{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-19","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-19","excerpt":""}],"posts":[{"title":"非著名不专业程序员必备工具","text":"智能搜索工具Alfred 作为一名非著名不专业程序员，搜索几乎占据我们大部分时间。而这款软件可以堪称是利器，无论是谷歌百度还是快捷打开软件都可以大量节省我们时间。推荐 Alfred 插件：1. CodeVar : 可以让英文稀烂的你一样能写出一个标准英文变量名2. Kill Process: 快捷杀死程序 编程语言Api文档 Dash Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 接口调试工具 postman 引用官网一句话： Developers use Postman to build modern software for the API-first world. 代码管理可视化工具 SVN： 使用cornerstone Git: 使用Sourcetree Finder扩展工具 TotalFinder TotalFinder是mac搜索增强工具，具有多标签式浏览、拷贝路径、剪切文件、显示隐藏文件、双窗口模式等功能，让你浏览和搜索文件更加方便 MarkDown笔记编写工具 FaIcon 如果你像我一样比较懒不喜欢记MarkDown语法，那么就可以使用这款MarkDown 工具，内置常用语法标签按钮 邮件应用 Airmail 如果你像我一样喜欢根据个人习惯来定制应用，以求效率最大化的人，Airmail 高度的可定制性一定会让你欣喜若狂。只要你上手体验几分钟，你也会像我一样得出「Airmail 是现在 iOS 上可自定义程度最高的邮件应用」 强大的终端工具 ITerm2 如果你像我一样也喜欢搞些花里胡哨的界面，还可以配合oh-my-zsh插件做一些自定义配色方案 ~~~~最后送给大家两个Mac破解软件的网站大部分破解软件都能搜索到。精品MAC应用分享史蒂芬周的博客","path":"2018/03/20/非著名不专业程序员必备工具/","date":"03-20","excerpt":""},{"title":"Instruments使用","text":"Instruments 是 Xcode 提供我们调试App性能的分析工具 打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面 Core AnimationCore Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿. Color Blended Layers，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。 Color Hits Green and Misses Red，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。 Color Copied Images，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。 Color Non-Standard Surface Formats, 不标准的表面颜色格式. Color Immediately，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。 Color Misaligned Images，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。 Color Offscreen-Rendered Yellow，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。 Color Compositing Fast Path Blue，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。 Flash Updated Regions，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。 Leaks关于内存方面的监控, 有Leaks用来检测内存泄漏, Zombies用来检测僵尸对象. 关于内存泄漏常见的几种情况, 可以参考这里 Time Profiler这个主要是用来统计各个方法消耗的时间.如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的. Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Time Profiler无法定位到代码 Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File Profile要在debug模式下运行, BuildConfiguration要选择debug. 参考资料 iOS 性能优化：Instruments 工具的救命三招 Instruments性能优化-Core Animation 使用 Instruments 做 iOS 程序性能调试 关于内存泄漏，还有哪些是你不知道的？ 使用Instruments定位iOS应用的Memory Leaks instrument Time Profiler总结","path":"2017/04/28/Instruments使用/","date":"04-28","excerpt":""},{"title":"iOS内存分配","text":"计算机系统中，应用程序的数据都保存在内存中，不同的数据类型保存的区域也不同。 RAM和ROM RAM：运行时内存，程序在运行过程中的使用的内存，不能掉电存储 ROM：存储形内存（内存卡），RAM的速度和价格都高于ROM App程序启动，系统会把存储在ROM中的程序拷贝到RAM中，然后从内存里面执行代码 内存分区堆区：Heap堆区由程序员来分配(oc: alloc swift: init)和释放 ARC下的内存管理由编译器自动添加retain, release, autorelease等关键字 堆区的地址由低到高分配 不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理) 堆空间的分配总是动态的 需要程序猿进行分配和释放 栈区 Stack栈区是由编译器自动分配和释放的，用来存放局部变量，函数的参数值，函数跳转地址等iPhone栈区大小是512K 不需要我们管理栈区变量的内存 栈区地址从高到低分配 先进后出栈空间有静态分配和动态分配两种 静态分配是由编译器完成，比如自动变量auto的分配. 动态分配由alloca函数完成. 栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配. 全局区 static全局区也叫做静态区，全局变量和静态变量在内存中是存放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和静态变量放在相邻的宁一块区域，程序结束后由系统释放 常量区存放字符串常量，程序结束后由系统自己释放 代码区代码区用于存放函数的二进制代码，App的代码，程序结束后由系统释放 内存分区地址如图所示：代码区的地址最低，栈区最高，但区与区之间的地址不连续 栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便. 系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容). 变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回. 当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃. 申请内存后系统的响应 栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小. 堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去. 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.堆获得的空间比较灵活, 也比较大.","path":"2017/04/14/page/","date":"04-14","excerpt":""}]}